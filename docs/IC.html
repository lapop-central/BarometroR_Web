<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Intervalos de confianza usando el Barómetro de las Américas</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">LAPOP_edu</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Preparación
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="instalando.html">Instalando R y RStudio</a>
    </li>
    <li>
      <a href="bases.html">Importación de bases de datos</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Aspectos iniciales
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Manipulacion.html">Manejo de datos</a>
    </li>
    <li>
      <a href="Expansion.html">Factor de expansión</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Describir y graficar
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Descriptivos.html">Descriptivos variables nominales</a>
    </li>
    <li>
      <a href="Descriptivos2.html">Descriptivos variables ordinales</a>
    </li>
    <li>
      <a href="Descriptivos3.html">Descriptivos variables numéricas</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Inferencia básica
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="IC.html">Intervalos de confianza</a>
    </li>
    <li>
      <a href="pruebat.html">Comparación de 2 medias</a>
    </li>
    <li>
      <a href="anova.html">Comparación de varias medias</a>
    </li>
    <li>
      <a href="chi.html">Tablas cruzadas y chi-cuadrado</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Modelamiento
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="correlacion.html">Correlación</a>
    </li>
    <li>
      <a href="regresion1.html">Regresión lineal simple</a>
    </li>
    <li>
      <a href="regresion2.html">Regresión lineal multivariada</a>
    </li>
    <li>
      <a href="logit.html">Regresión logística</a>
    </li>
  </ul>
</li>
<li>
  <a href="Links.html">Contacto</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Intervalos de confianza usando el Barómetro
de las Américas</h1>

</div>


<style type="text/css">
.columns {display: flex;}
h1 {color: #3366CC;}
</style>
<div id="introducción" class="section level1">
<h1>Introducción</h1>
<p>En este documento veremos como construir intervalos de confianza de
la media usando los datos del Barómetro de las Américas. Para eso, vamos
a usar los reportes “El pulso de la democracia” de 2018/19, disponible
<a
href="https://www.vanderbilt.edu/lapop/ab2018/2018-19_AmericasBarometer_Regional_Report_Spanish_W_03.27.20.pdf">aquí</a>,
y de 2021, disponible <a
href="https://www.vanderbilt.edu/lapop/ab2021/2021_LAPOP_AmericasBarometer_Pulse_of_Democracy.pdf">aquí</a>.
En la ronda 2018/19, una de las secciones de este informe, reporta los
datos sobre redes sociales y actitudes políticas. En particular, se
reporta, en el gráfico 3.9, el grado de satisfacción con la democracia
por tipo de usuario de redes sociales. En la ronda 2021, una de las
secciones reporta los datos sobre golpes ejecutivos. En el gráfico 1.7
se presenta el porcentaje de ciudadanos que toleran los golpes
ejecutivos por país. En ambos casos, los resultados incluyen las
estimaciones puntuales y los intervalos de confianza.</p>
</div>
<div id="sobre-las-bases-de-datos" class="section level1">
<h1>Sobre las bases de datos</h1>
<p>Los datos que vamos a usar deben citarse de la siguiente manera:
Fuente: Barómetro de las Américas por el Proyecto de Opinión Pública de
América Latina (LAPOP), wwww.LapopSurveys.org. En este documento se
carga una base de datos recortada. Esta base de datos se encuentra
alojada en el repositorio “materials_edu” de la cuenta de LAPOP en
GitHub. Se recomiendo limpiar el Environment antes de proceder con esta
sección.</p>
<p>Mediante la librería <code>rio</code> y el comando
<code>import</code> se puede importar esta base de datos desde este
repositorio. Además, se seleccionan los datos de países con códigos
menores o iguales a 35, es decir, se elimina las observaciones de
Estados Unidos y Canadá.</p>
<pre class="r"><code>library(rio)
lapop18 &lt;- import(&quot;https://raw.github.com/lapop-central/materials_edu/main/LAPOP_AB_Merge_2018_v1.0.sav&quot;)
lapop18 &lt;- subset(lapop18, pais&lt;=35)</code></pre>
<p>También cargamos la base de datos de la ronda 2021.</p>
<pre class="r"><code>lapop21 = import(&quot;lapop21.RData&quot;)
lapop21 &lt;- subset(lapop21, pais&lt;=35)</code></pre>
</div>
<div id="tolerancia-a-los-golpes-ejecutivos" class="section level1">
<h1>Tolerancia a los golpes ejecutivos</h1>
<p>El gráfico 1.7 del reporte El pulso de la Democracia para la ronda
del Barómetro de las Américas 2021 presenta los resultados del
porcentaje de ciudadanos que tolera un golpe ejecutivo. Este gráfico,
además, presente el intervalo de confianza al 95% de este porcentaje en
cada país.</p>
<p><img src="Figure1.7.png" width="564" /></p>
<p>La variable para construir este gráfico es “jc15a” que está fraseada:
¿Cree usted que cuando el país enfrenta momentos muy difíciles, se
justifica que el presidente del país cierre el Congreso/Asamblea y
gobierno sin Congreso/Asamblea? Las opciones de respuesta son:</p>
<ol style="list-style-type: decimal">
<li>Sí se justifica</li>
<li>No se justifica</li>
</ol>
<div id="describiendo-la-tolerancia-a-los-golpes-ejecutivos"
class="section level2">
<h2>Describiendo la tolerancia a los golpes ejecutivos</h2>
<p>Para calculas los porcentajes de ciudadanos que justifican o toleran
los golpes ejecutivos se tiene que recodificar esta variable, de tal
manera que aquellos que justifican tengan el valor 100 y los que no
justifican, el valor 0. En este caso se usa el comando
<code>recode</code> y se tabula, mediante <code>table</code>, para
verificar la recodificación.</p>
<pre class="r"><code>lapop21$jc15ar &lt;- car::recode(lapop21$jc15a, &quot;1=100; 2=0&quot;)
table(lapop21$jc15ar)</code></pre>
<pre><code>## 
##     0   100 
## 14711  5908</code></pre>
<p>Para calcular el porcentaje de ciudadanos que toleran los golpes
ejecutivos se puede usar los comandos <code>table</code> y
<code>prop.table</code>. La nueva variable “jc15ar” es una variable
dummy. En este tipo de variables, la media corresponde a la proporción
de respuestas 100. Es decir, si calculamos la media de esta variable, se
está calculando el porcentaje para todos los entrevistados. En esta
sección vamos a tratar a esta variable como si fuera una variable
numérica. En sentido estricto es una variable categórica nominal. Los
cálculos de desviaciones estándar y luego de intervalos de confianza,
por lo tanto, son referenciales.</p>
<p>El resultado indica que en toda la muestra, el porcentaje de
ciudadanos que toleran los golpes ejecutivos es de 28.7%.</p>
<pre class="r"><code>summary(lapop21$jc15ar)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA&#39;s 
##    0.00    0.00    0.00   28.65  100.00  100.00   40042</code></pre>
</div>
<div id="intervalos-de-confianza-de-tolerancia-a-los-golpes-ejecutivos"
class="section level2">
<h2>Intervalos de confianza de tolerancia a los golpes ejecutivos</h2>
<p>Para calcular el intervalo de confianza al 95% de este porcentaje, se
puede usar el comando <code>t.test</code> o la librería
<code>lsr</code>, que tiene el comando <code>ciMean</code>. En ambos
casos, el resultado nos indica que el porcentaje de ciudadanos que
tolera los golpes ejecutivos en la región está entre 28% y 29.3%.</p>
<pre class="r"><code>t.test(lapop21$jc15ar)</code></pre>
<pre><code>## 
##  One Sample t-test
## 
## data:  lapop21$jc15ar
## t = 90.996, df = 20618, p-value &lt; 2.2e-16
## alternative hypothesis: true mean is not equal to 0
## 95 percent confidence interval:
##  28.03599 29.27038
## sample estimates:
## mean of x 
##  28.65318</code></pre>
<pre class="r"><code>library(lsr)
ciMean(as.numeric(lapop21$jc15ar), na.rm=T)</code></pre>
<pre><code>##          2.5%    97.5%
## [1,] 28.03599 29.27038</code></pre>
</div>
<div id="tolerancia-a-los-golpes-ejecutivos-por-país"
class="section level2">
<h2>Tolerancia a los golpes ejecutivos por país</h2>
<p>El gráfico 1.7 muestra el porcentaje de ciudadanos que toleran los
golpes ejecutivos por país. Para replicar este gráfico, primero tenemos
que definir que la variable “pais” es de tipo factor. Se guarda este
cambio en una nueva variable “paises”, la que se etiqueta con las siglas
de cada país.</p>
<pre class="r"><code>lapop21$paises &lt;- as.factor(lapop21$pais)
levels(lapop21$paises) &lt;- c(&quot;MX&quot;, &quot;GT&quot;, &quot;SV&quot;, &quot;HN&quot;, &quot;NI&quot;, &quot;CR&quot;,
                            &quot;PN&quot;, &quot;CO&quot;, &quot;EC&quot;, &quot;BO&quot;, &quot;PE&quot;,
                            &quot;PY&quot;, &quot;CL&quot;, &quot;UY&quot;, &quot;BR&quot;, &quot;AR&quot;, &quot;DO&quot;,
                            &quot;HT&quot;, &quot;JA&quot;, &quot;GU&quot;)
table(lapop21$paises)</code></pre>
<pre><code>## 
##   MX   GT   SV   HN   NI   CR   PN   CO   EC   BO   PE   PY   CL   UY   BR   AR 
## 2998 3000 3245 2999 2997 2977 3183 3003 3005 3002 3038 3004 2954 3009 3016 3011 
##   DO   HT   JA   GU 
## 3000 3088 3121 3011</code></pre>
<p>Para calcular estos porcentajes por país, se puede usar varias
alternativas. Por ejemplo, el comando <code>tapply</code> permite
calcular la media de una variable por grupos de otra variable.</p>
<pre class="r"><code>tapply(lapop21$jc15ar, lapop21$paises, mean, na.rm=T)</code></pre>
<pre><code>##        MX        GT        SV        HN        NI        CR        PN        CO 
## 30.312500 36.687307 48.068670 22.660819 31.111111       NaN 28.962444 35.041447 
##        EC        BO        PE        PY        CL        UY        BR        AR 
## 31.944444 32.082414 43.805613 34.459459 16.544118  8.552632 23.862069 13.795620 
##        DO        HT        JA        GU 
## 25.495959 44.042553 30.583215       NaN</code></pre>
<p>Otra forma es usar las librerías <code>plyr</code> y
<code>dplyr</code> que incluye el comando <code>ddply</code>. Este
comando requiere que se defina el dataframe “lapop21”, la variable de
agrupamiento “paises” y luego las funciones que se requiere en cada
grupo, que en este caso son “mean” y “sd”.</p>
<pre class="r"><code>library(plyr)
library(dplyr)
ddply(lapop21, &quot;paises&quot;, summarise, mean=mean(jc15ar, na.rm=T), sd=sd(jc15ar, na.rm=T))</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["paises"],"name":[1],"type":["fct"],"align":["left"]},{"label":["mean"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["sd"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"MX","2":"30.312500","3":"45.99683"},{"1":"GT","2":"36.687307","3":"48.23249"},{"1":"SV","2":"48.068670","3":"49.99846"},{"1":"HN","2":"22.660819","3":"41.89433"},{"1":"NI","2":"31.111111","3":"46.32915"},{"1":"CR","2":"NaN","3":"NA"},{"1":"PN","2":"28.962444","3":"45.37325"},{"1":"CO","2":"35.041447","3":"47.72796"},{"1":"EC","2":"31.944444","3":"46.64234"},{"1":"BO","2":"32.082414","3":"46.69652"},{"1":"PE","2":"43.805613","3":"49.63180"},{"1":"PY","2":"34.459459","3":"47.54144"},{"1":"CL","2":"16.544118","3":"37.17149"},{"1":"UY","2":"8.552632","3":"27.97656"},{"1":"BR","2":"23.862069","3":"42.63874"},{"1":"AR","2":"13.795620","3":"34.49799"},{"1":"DO","2":"25.495959","3":"43.59987"},{"1":"HT","2":"44.042553","3":"49.69672"},{"1":"JA","2":"30.583215","3":"46.09229"},{"1":"GU","2":"NaN","3":"NA"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Como se observa en la tabla, no hay datos para Costa Rica, ni para
Guyana. Con el cálculo de la desviación estándar, se podría calcular el
límite inferior y superior del intervalo de confianza.</p>
<p>Esto se puede hacer de manera directa con la librería
<code>Rmisc</code>. Esta librería tiene el comando
<code>group.CI</code>, que calcula la media, el límite inferior y
superior de una variable por grupos de otra variable. Esta tabla se
guarda en un objeto llamado “golpe”. Este comando no incluye las filas
de los países donde no hay datos, por lo que no hay filas de Costa Rica
ni de Guyana.</p>
<pre class="r"><code>library(Rmisc)
golpe &lt;- group.CI(jc15ar~paises, lapop21)
golpe</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["paises"],"name":[1],"type":["fct"],"align":["left"]},{"label":["jc15ar.upper"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["jc15ar.mean"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["jc15ar.lower"],"name":[4],"type":["dbl"],"align":["right"]}],"data":[{"1":"MX","2":"33.88284","3":"30.312500","4":"26.742162"},{"1":"GT","2":"40.41369","3":"36.687307","4":"32.960926"},{"1":"SV","2":"51.78163","3":"48.068670","4":"44.355713"},{"1":"HN","2":"25.80600","3":"22.660819","4":"19.515638"},{"1":"NI","2":"34.61243","3":"31.111111","4":"27.609797"},{"1":"PN","2":"31.20785","3":"28.962444","4":"26.717039"},{"1":"CO","2":"37.61174","3":"35.041447","4":"32.471157"},{"1":"EC","2":"34.35553","3":"31.944444","4":"29.533359"},{"1":"BO","2":"34.56732","3":"32.082414","4":"29.597507"},{"1":"PE","2":"46.35270","3":"43.805613","4":"41.258529"},{"1":"PY","2":"37.01489","3":"34.459459","4":"31.904033"},{"1":"CL","2":"18.52143","3":"16.544118","4":"14.566804"},{"1":"UY","2":"10.03646","3":"8.552632","4":"7.068802"},{"1":"BR","2":"26.05857","3":"23.862069","4":"21.665568"},{"1":"AR","2":"15.62400","3":"13.795620","4":"11.967243"},{"1":"DO","2":"27.81437","3":"25.495959","4":"23.177545"},{"1":"HT","2":"48.54708","3":"44.042553","4":"39.538028"},{"1":"JA","2":"32.99455","3":"30.583215","4":"28.171877"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Con esta tabla podemos replicar el gráfico 1.7 con la librería
<code>ggplot2</code>. Para incluir los intervalos de confianza se tiene
que agregar la especificación <code>geom_errorbar()</code>. La tabla
“golpe” tiene el dato de “ymin” en la columna “jc15ar.lower” y el dato
de “ymax” en la columna “jc15ar.upper”. Estos datos se deben ingresar en
la especificación <code>aes</code> dentro de <code>geom_errorbar</code>.
Además, se tiene como opciones <code>width</code> para especificar el
ancho de las bigotes de las barras de error, <code>color</code> para
especificar el color, <code>cex</code> para especificar el ancho de las
líneas y <code>linetype</code> para especificar el tipo de líneas, en
este caso puntuadas.</p>
<p>Para poder ordenar las barras de acuerdo al valor de la variable, se
puede usar la especificación <code>reorder(grupo, variable)</code>
dentro de la especificación <code>aes</code> de <code>ggplot</code>.</p>
<pre class="r"><code>library(ggplot2)
graf1 &lt;- ggplot(golpe, aes(x=reorder(paises, -jc15ar.mean), y=jc15ar.mean))+
  geom_bar(width=0.5, fill=&quot;darkslategray3&quot;, colour=&quot;#69b3a2&quot;, stat=&quot;identity&quot;)+
  geom_errorbar(aes(ymin=jc15ar.lower, ymax=jc15ar.upper), width=0.4, 
                color=&quot;darkcyan&quot;, cex=0.4, linetype=3)+
  geom_text(aes(label=paste(round(jc15ar.mean, 1), &quot;%&quot;)), vjust=-4.4, size=2.5)+
  xlab(&quot;País&quot;) + ylab(&quot;Tolerancia a golpes ejecutivos (%)&quot;)+
  ylim(0, 60)
graf1</code></pre>
<p><img
src="IC_files/figure-html/grafico%20tolerancia%20por%20pais-1.png" /><!-- --></p>
<p>Estos datos, sin embargo, no son exactamente iguales a los
presentados en el gráfico 1.7 debido a que estos cálculos no incluyen el
efecto de diseño. Más adelante, se verá cómo incluir el efecto de diseño
para replicar el gráfico exactamente.</p>
</div>
</div>
<div id="satisfacción-con-la-democracia" class="section level1">
<h1>Satisfacción con la democracia</h1>
<p>El gráfico 3.9 del reporte El Pulso de la Democracia de la ronda
2018/19 presenta el porcentaje de entrevistados que está satisfecho con
la democracia por tipo de usuarios de redes sociales.</p>
<p><img src="Graf3.9.png" width="413" /></p>
<p>La variable satisfacción con la democracia se llama “pn4” y está
codificada de la siguiente manera:</p>
<ol style="list-style-type: decimal">
<li>Muy satisfecho</li>
<li>Satisfecho</li>
<li>Insatisfecho</li>
<li>Muy insatisfecho</li>
</ol>
<p>La nota 21 de este reporte indica que “Se codifica a los
entrevistados que seleccionan (1) o (2) como satisfechos con la
democracia”. Por lo tanto, se tiene que recodificar esta variable. En
este caso se usa el comando <code>recode</code> y se tabula, mediante
<code>table</code>, para verificar la recodificación.</p>
<pre class="r"><code>library(car)
table(lapop18$pn4)</code></pre>
<pre><code>## 
##     1     2     3     4 
##  1727  8916 12455  3855</code></pre>
<pre class="r"><code>lapop18$pn4rr &lt;- car::recode(lapop18$pn4, &quot;1:2=100; 3:4=0&quot;)
table(lapop18$pn4rr)</code></pre>
<pre><code>## 
##     0   100 
## 16310 10643</code></pre>
<p>La nueva variable “pn4rr” es una variable dummy. En este tipo de
variables, la media corresponde a la proporción de respuestas 100. Es
decir, si calculamos la media de esta variable, se está calculando el
porcentaje para todos los entrevistados. En esta sección vamos a tratar
a esta variable como si fuera una variable numérica. En sentido estricto
es una variable categórica nominal. Los cálculos de desviaciones
estándar y luego de intervalos de confianza, por lo tanto, son
referenciales.</p>
<pre class="r"><code>summary(lapop18$pn4rr)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA&#39;s 
##    0.00    0.00    0.00   39.49  100.00  100.00    1089</code></pre>
<p>Estos resultados muestran una media de 39.5, es decir el 39.5% de los
entrevistados están satisfechos con la democracia. Se puede calcular
también el intervalo de confianza de esta variable de varias formas. Una
primera es mediante la prueba t de una muestra, usando el comando
<code>t.test</code>. Otra forma es usando el comando <code>ciMean</code>
de la librería <code>lsr</code>.</p>
<pre class="r"><code>t.test(lapop18$pn4rr)</code></pre>
<pre><code>## 
##  One Sample t-test
## 
## data:  lapop18$pn4rr
## t = 132.62, df = 26952, p-value &lt; 2.2e-16
## alternative hypothesis: true mean is not equal to 0
## 95 percent confidence interval:
##  38.90364 40.07087
## sample estimates:
## mean of x 
##  39.48726</code></pre>
<pre class="r"><code>library(lsr)
ciMean(lapop18$pn4rr, na.rm=T)</code></pre>
<pre><code>##          2.5%    97.5%
## [1,] 38.90364 40.07087</code></pre>
<p>Estos resultados indican que el intervalo de confianza de la media de
satisfacción con la democracia varía entre 38.9% y 40.1% con 95% de
confianza. Se podría cambiar este valor por defecto a 99% de confianza
agregando la especificación <code>conf = 0.99</code> al comando
<code>ciMean</code>.</p>
<div
id="satisfacción-con-la-democracia-por-grupos-de-consumo-de-información-en-redes-sociales"
class="section level2">
<h2>Satisfacción con la democracia por grupos de consumo de información
en redes sociales</h2>
<p>El informe usa una variable que mide la “exposición frecuente a
información política”. Esta variable se construye de una manera
compleja, sobre la base de las 3 redes sociales por las que se pregunta.
En este caso vamos a empezar con una recodificación más simple para
recrear los intervalos de confianza de la variable “satisfacción de la
democracia” por grupo de frecuencia de consumo de información de cada
red social. Luego se procederá a replicar la variable que se usa en el
reporte. La frecuencia de consumo de información (variables “smedia2”
para Facebook, “smedia5” para Twitter y “smedia8” para Whatsapp) de cada
red social se mide en la siguiente escala:</p>
<ol style="list-style-type: decimal">
<li>Diariamente</li>
<li>Algunas veces a la semana</li>
<li>Algunas veces al mes</li>
<li>Algunas veces al año</li>
<li>Nunca</li>
</ol>
<p>Vamos a recodificar estas variables de tal manera que aquellos que
responden diariamente o algunas veces a la semana serán clasificados
como de “alto uso”, aquellos que responden del 3 al 4 serán clasificados
como de “bajo uso” y aquellos que responden “nunca” serán clasificados
como “no usuarios”. Un esquema similar de clasificación se usa para
definir a los usuarios de las 3 redes sociales. Las nuevas variables
recodificadas, se convierten a factor y se etiquetan.</p>
<pre class="r"><code>table(lapop18$smedia2)</code></pre>
<pre><code>## 
##    1    2    3    4    5 
## 8633 4927 1286  282  231</code></pre>
<pre class="r"><code>table(lapop18$smedia5)</code></pre>
<pre><code>## 
##   1   2   3   4   5 
## 795 728 422 193 220</code></pre>
<pre class="r"><code>table(lapop18$smedia8)</code></pre>
<pre><code>## 
##     1     2     3     4     5 
## 14151  2646   495    50    87</code></pre>
<pre class="r"><code>lapop18$smedia2r &lt;- car::recode(lapop18$smedia2, &quot;1:2=1; 3:4=2; 5=3&quot;)
lapop18$smedia5r &lt;- car::recode(lapop18$smedia5, &quot;1:2=1; 3:4=2; 5=3&quot;)
lapop18$smedia8r &lt;- car::recode(lapop18$smedia8, &quot;1:2=1; 3:4=2; 5=3&quot;)
lapop18$smedia2r &lt;- as.factor(lapop18$smedia2r)
lapop18$smedia5r &lt;- as.factor(lapop18$smedia5r)
lapop18$smedia8r &lt;- as.factor(lapop18$smedia8r)
levels(lapop18$smedia2r) &lt;- c(&quot;Alto uso&quot;, &quot;Bajo uso&quot;, &quot;No usuario&quot;)
levels(lapop18$smedia5r) &lt;- c(&quot;Alto uso&quot;, &quot;Bajo uso&quot;, &quot;No usuario&quot;)
levels(lapop18$smedia8r) &lt;- c(&quot;Alto uso&quot;, &quot;Bajo uso&quot;, &quot;No usuario&quot;)
table(lapop18$smedia2r)</code></pre>
<pre><code>## 
##   Alto uso   Bajo uso No usuario 
##      13560       1568        231</code></pre>
<pre class="r"><code>table(lapop18$smedia5r)</code></pre>
<pre><code>## 
##   Alto uso   Bajo uso No usuario 
##       1523        615        220</code></pre>
<pre class="r"><code>table(lapop18$smedia8r)</code></pre>
<pre><code>## 
##   Alto uso   Bajo uso No usuario 
##      16797        545         87</code></pre>
<p>Con estas variables recodificadas, se puede calcular las medias (que
son los porcentajes) de satisfacción con la democracia por cada grupo de
consumo de información en redes sociales. Esto se puede hacer de
múltiples maneras. Si se requiere comparar las medias, se puede usar el
comando <code>tapply</code>.</p>
<pre class="r"><code>tapply(lapop18$pn4rr, lapop18$smedia2r, mean, na.rm=T) #Facebook</code></pre>
<pre><code>##   Alto uso   Bajo uso No usuario 
##   37.55182   37.94466   40.74074</code></pre>
<pre class="r"><code>tapply(lapop18$pn4rr, lapop18$smedia5r, mean, na.rm=T) #Twitter</code></pre>
<pre><code>##   Alto uso   Bajo uso No usuario 
##   39.66777   37.37542   41.78404</code></pre>
<pre class="r"><code>tapply(lapop18$pn4rr, lapop18$smedia8r, mean, na.rm=T) #Whatsapp</code></pre>
<pre><code>##   Alto uso   Bajo uso No usuario 
##   37.39093   38.92100   43.37349</code></pre>
<p>Otra opción que puede presentar tanto la media como la desviación
estándar es mediante la librería <code>plyr</code> y el comando
<code>ddply</code>. El código solo para Facebook sería:</p>
<pre class="r"><code>library(plyr)
ddply(lapop18, &quot;smedia2r&quot;, summarise, mean=mean(pn4rr, na.rm=T), sd=sd(pn4rr, na.rm=T))</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["smedia2r"],"name":[1],"type":["fct"],"align":["left"]},{"label":["mean"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["sd"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"Alto uso","2":"37.55182","3":"48.42747"},{"1":"Bajo uso","2":"37.94466","3":"48.54092"},{"1":"No usuario","2":"40.74074","3":"49.24932"},{"1":"NA","2":"41.80890","3":"49.32656"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Es importante notar que en este caso no hemos indicado que
internamente no se trabaje con los valores perdidos (usando la
especificación <code>filter(!is.na(wa_user))</code>), por lo que la
tabla anterior presenta una fila de las observaciones NA de usuario de
la red social, donde se calcula el promedio y la desviación estándar de
la variable satisfacción con la democracia. Finalmente, una opción que
permite mostrar muchos estadísticos por cada grupo es
<code>describeBy</code> de la librería <code>psych</code>. El código
para Twitter es:</p>
<pre class="r"><code>library(psych)
describeBy(lapop18$pn4rr, group=lapop18$smedia5r)</code></pre>
<pre><code>## 
##  Descriptive statistics by group 
## group: Alto uso
##    vars    n  mean    sd median trimmed mad min max range skew kurtosis   se
## X1    1 1505 39.67 48.94      0    37.1   0   0 100   100 0.42    -1.82 1.26
## ------------------------------------------------------------ 
## group: Bajo uso
##    vars   n  mean    sd median trimmed mad min max range skew kurtosis   se
## X1    1 602 37.38 48.42      0   34.23   0   0 100   100 0.52    -1.73 1.97
## ------------------------------------------------------------ 
## group: No usuario
##    vars   n  mean    sd median trimmed mad min max range skew kurtosis   se
## X1    1 213 41.78 49.44      0   39.77   0   0 100   100 0.33     -1.9 3.39</code></pre>
<p>Sin embargo, lo que nos interesa es calcular los intervalos de
confianza para cada grupo. En el gráfico 3.9 del reporte se presenta la
media de satisfacción con la democracia, mostrado como un punto, y los
intervalos de confianza de cada grupo, mostrados como un área gris con
límites inferior y superior. Se puede usar la librería
<code>Rmisc</code> y el comando <code>group.CI</code> para calcular los
intervalos de confianza de la variable satisfacción con la democracia
por grupos de consumo de información en Facebook.</p>
<pre class="r"><code>library(Rmisc)
group.CI(pn4rr~smedia2r, lapop18)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["smedia2r"],"name":[1],"type":["fct"],"align":["left"]},{"label":["pn4rr.upper"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["pn4rr.mean"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["pn4rr.lower"],"name":[4],"type":["dbl"],"align":["right"]}],"data":[{"1":"Alto uso","2":"38.37595","3":"37.55182","4":"36.72770"},{"1":"Bajo uso","2":"40.38847","3":"37.94466","4":"35.50086"},{"1":"No usuario","2":"47.34574","3":"40.74074","4":"34.13574"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Con estos datos, por ejemplo, la media de satisfacción con la
democracia entre el grupo de alto uso de información en Facebook es
37.6%. El límite inferior del intervalo de confianza es 36.7% y el
límite superior es 38.4%. Con estos datos se podría replicar un gráfico
de barras similar al 3.9.</p>
</div>
<div id="intervalos-de-confianza-de-satisfacción-con-la-democracia"
class="section level2">
<h2>Intervalos de confianza de satisfacción con la democracia</h2>
<p>La forma más fácil de graficar los intervalos de confianza por grupos
es usando el comando <code>plotmeans</code>.</p>
<pre class="r"><code>library(gplots)
plotmeans(lapop18$pn4rr~lapop18$smedia5r,
          xlab=&quot;Tipo de usuario de Twitter&quot;,
          ylab=&quot;Satisfacción con la democracia&quot;,
          ylim=c(0, 50),
          mean.labels=T, digits=1,
          connect=F
         )</code></pre>
<p><img src="IC_files/figure-html/grafxgrup-1.png" /><!-- --></p>
<p>Esta opción muestra los intervalos de confianza pero se dificulta si
se quiere graficar las barras. La librería <code>ggplot</code> nos
brinda más opciones y nos permite graficar de manera similar al gráfico
3.9 del reporte, en barras, presentar los intervalos de confianza y
agregar color. Para esto, primero se guarda un dataframe “tw.uso” con
los datos de la media y los límites superior e inferior de cada grupo,
usando el comando <code>group.CI</code>. Son los datos de este dataframe
los que se usan con <code>ggplot</code> y se crea un gráfico que se
guarda en un objeto “graf1”. Con esta librería se agrega la capa
<code>geom_bar()</code> para definir que se quiere un gráfico de barras
de las variables especificadas en <code>aes</code>. Luego, se agrega la
capa <code>geom_errorbar()</code> para agregar las barras de error y
luego los valores de la media con <code>geom_text()</code>. Finalmente,
se etiqueta el eje X y Y con <code>xlab</code> y <code>ylab</code> y se
define los límites del eje Y con <code>ylim</code>.</p>
<pre class="r"><code>tw.uso &lt;- group.CI(pn4rr~smedia5r, lapop18)
library(ggplot2)
graf2 &lt;- ggplot(tw.uso, aes(x=smedia5r, y=pn4rr.mean))+
  geom_bar(width=0.5, fill=&quot;darkcyan&quot;, colour=&quot;black&quot;, stat=&quot;identity&quot;)+
  geom_errorbar(aes(ymin=pn4rr.lower, ymax=pn4rr.upper), width=0.2)+
  geom_text(aes(label=paste(round(pn4rr.mean, 1), &quot;%&quot;)), vjust=-4.2, size=4)+
  xlab(&quot;Tipo de usuario de Twitter&quot;) + ylab(&quot;Satisfacción con la democracia (%)&quot;)+
  ylim(0, 50)
graf2</code></pre>
<p><img src="IC_files/figure-html/grafxgrup2-1.png" /><!-- --></p>
<p>Según estos resultados, la satisfacción con la democracia es más alta
en aquellos que no son usuarios de Twitter, en comparación con los
usuarios, aunque las diferencias no son estadísticamente significativas
de una comparación visual entre los intervalos de confianza.</p>
</div>
<div
id="satisfacción-con-la-democracia-por-tipo-de-usuario-de-redes-sociales"
class="section level2">
<h2>Satisfacción con la democracia por tipo de usuario de redes
sociales</h2>
<p>Hasta el momento se ha creado intervalos de confianza de satisfacción
con la democracia por tipo de usuarios de Twitter. El reporte agrega a
los usuarios de las tres redes sociales para ubicar tres tipos de
usuarios: usuarios de alto uso, de bajo uso y no usuarios de cualquier
red social. La forma de codificación de este tipo de usuarios de tres
redes sociales se basa en varias condiciones. Como dice el reporte:
“Usamos la misma codificación que en la anterior sección, para
distinguir entre quienes acceden con frecuencia en redes sociales
(aquellos con cuentas a las que acceden algunas veces a la semana o a
diario) y aquellos que no acceden a las redes sociales muy
frecuentemente (aquellos con cuentas a las que acceden algunas veces al
mes o algunas veces al año). También incluimos a quienes no son
usuarios: quienes no tienen ninguna cuenta en redes sociales (quienes
indican que no tienen una cuenta en Facebook, Twitter o Whatsapp) y
quienes tienen una cuenta, pero nunca la usan” (p.81). En primer lugar
identificamos a quienes usan cada red social algunas veces a la semana o
a diario como 1 y si usan cada red social algunas veces al mes o algunas
veces al año, como 0. Para esto usamos el comando <code>ifelse</code>.
Luego, sumamos los valores de cada red social en una sola variable, con
valores entre 0 y 3. Se usa el comando <code>rowSums</code> que permite
la suma horizontal de variables definidas, en este caso las que están en
la posición <code>[, 89:91]</code>. En este comando, usamos la
especificación <code>na.rm=T</code> para que la suma no tome en cuenta a
los valores perdidos.</p>
<pre class="r"><code>lapop18$sm2 &lt;- ifelse(lapop18$smedia2==1 | lapop18$smedia2==2, 1, 0)
lapop18$sm5 &lt;- ifelse(lapop18$smedia5==1 | lapop18$smedia5==2, 1, 0)
lapop18$sm8 &lt;- ifelse(lapop18$smedia8==1 | lapop18$smedia8==2, 1, 0)
lapop18$anyhi = rowSums(lapop18[,89:91], na.rm=T)
table(lapop18$anyhi)</code></pre>
<pre><code>## 
##     0     1     2     3 
##  9831  5811 11131  1269</code></pre>
<p>Partiendo de esta variable, se crea una variable que agrega las tres
redes sociales, llamada “hi_lo_non”. Primero, se crea esta variable como
un vector de NAs. Luego se le imputa valores de 1, 2, 3 o NA,
dependiendo de los valores de “anyhi o de los valores de las variables
de redes sociales. Luego se crea una nueva variable de tipo factor, con
idénticos valores que”hi_lo_non” y se etiqueta. La definición de la
condicionalidad se trabaja mediante los corchetes <code>[...]</code>. De
esta manera, se define las condiciones de la siguiente manera:</p>
<ul>
<li><p>La variable “hi_lo_non es igual a 1 si la variable anyhi es mayor
o igual a 1 (uso diario o algunas veces a la semana) =
<code>lapop18$hi_lo_non[lapop18$anyhi&gt;=1] &lt;- 1</code></p></li>
<li><p>La variable “hi_lo_non es igual a 2 si la variable anyhi es igual
a 0 (uso algunas veces al año o nunca) =
<code>lapop18$hi_lo_non[lapop18$anyhi==0] &lt;- 2</code></p></li>
<li><p>La variable “hi_lo_non es igual a 3 si las variables de tenencia
de cuentas son igual a 2 (No) =
<code>lapop18$hi_lo_non[lapop18$smedia1==2 &amp; lapop18$smedia4==2 &amp; lapop18$smedia7==2] &lt;- 3</code></p></li>
</ul>
<p>Las siguiente reglas de codificación siguen la misma lógica de
combinación de otras variables para imputar el valor 3 o NA.</p>
<pre class="r"><code>lapop18$hi_lo_non &lt;- NA #se crea un vector con NAs#
lapop18$hi_lo_non[lapop18$anyhi&gt;=1] &lt;- 1 #Se codifica 1 a los que usan diariamente o algunas veces a la semana alguna red social#
lapop18$hi_lo_non[lapop18$anyhi==0] &lt;- 2 #Se codifica como 2 a los que usan algunas veces al mes y al año alguna red social#
lapop18$hi_lo_non[lapop18$smedia1==2 &amp; lapop18$smedia4==2 &amp; lapop18$smedia7==2] &lt;- 3 #Se codifica como 3 a los que no tiene redes sociales#
lapop18$hi_lo_non[lapop18$smedia2==5 &amp; lapop18$smedia5==5 &amp; lapop18$smedia8==5] &lt;- 3 #Se codifica como 3 a los que nunca usan ninguna red social#
lapop18$hi_lo_non[lapop18$pais==3 &amp; (lapop18$smedia2==5 | lapop18$smedia5==5 | lapop18$smedia8==5)] &lt;- 3 #Se aplica un código particular a pais 3#
lapop18$hi_lo_non[lapop18$pais==3 &amp; (lapop18$smedia1==2 | lapop18$smedia4==2 | lapop18$smedia7==2)] &lt;- 3 #Se aplica un código particular a pais 3#
lapop18$hi_lo_non[lapop18$hi_lo_non != 1 &amp; (lapop18$smedia2==NA | lapop18$smedia5==NA | lapop18$smedia8==NA)] &lt;- NA #Se codifican los valores perdidos como perdidos#
lapop18$hi_lo_non[lapop18$hi_lo_non != 1 &amp; (lapop18$smedia1==NA | lapop18$smedia4==NA | lapop18$smedia7==NA)] &lt;- NA
lapop18$hi_lo_non[lapop18$smedia1==NA &amp; lapop18$smedia4==NA &amp; lapop18$smedia7==NA] &lt;- NA
lapop18$hi_lo_non[lapop18$hi_lo_non !=3 &amp; lapop18$smedia2==NA &amp; lapop18$smedia5==NA &amp; lapop18$smedia8==NA] &lt;- NA
lapop18$hilon &lt;- as.factor(lapop18$hi_lo_non)
levels(lapop18$hilon) &lt;- c(&quot;Alto uso&quot;, &quot;Bajo uso&quot;, &quot;No usuario&quot;)
prop.table(table(lapop18$hilon))*100</code></pre>
<pre><code>## 
##   Alto uso   Bajo uso No usuario 
##  64.941873   3.480494  31.577634</code></pre>
<p>Según estos datos, el 64.9% de entrevistados reportan un alto uso de
redes sociales, mientras que, en el otro extremo, se tiene 31.6% que
serían no usuarios de ninguna red social. Estos datos difieren un poco
de los reportados en el Apéndice al reporte, disponible <a
href="https://www.vanderbilt.edu/lapop/ab2018/Appendix_Material_for_2018-19_AmericasBarometer_Report-Comparative_Chapters_10.13.19.pdf">aquí</a>,
donde se reporte 65.34% de alto uso y 31.60% de no usuarios. Estas
diferencias pueden ser debidas a diferencias en la interpretación de las
reglas de codificación desde Stata a R.</p>
<p>De la misma forma que se produjo el gráfico de media de satisfacción
con la democracia por tipos de usuarios de Twitter usando
<code>ggplot</code>, ahora se hará lo mismo pero para los usuarios de
las tres redes sociales, variable “hilon”.</p>
<pre class="r"><code>library(Rmisc)
satis.uso &lt;- group.CI(pn4rr~hilon, lapop18)
library(ggplot2)
graf3.9 &lt;- ggplot(satis.uso, aes(x=hilon, y=pn4rr.mean))+
  geom_bar(width=0.5, fill=&quot;darkcyan&quot;, colour=&quot;black&quot;, stat=&quot;identity&quot;)+
  geom_errorbar(aes(ymin=pn4rr.lower, ymax=pn4rr.upper), width=0.2)+
  geom_text(aes(label=paste(round(pn4rr.mean, 1), &quot;%&quot;)), vjust=-2.5, size=4)+
  xlab(&quot;Tipo de usuario de redes sociales&quot;) + ylab(&quot;Satisfacción con la democracia (%)&quot;)+
  ylim(0, 50)
graf3.9</code></pre>
<p><img src="IC_files/figure-html/graf3.9-1.png" /><!-- --></p>
<p>Este gráfico sería una reproducción del que se presenta en el informe
(Gráfico 3.9 en la página 62), con una mínimas diferencias por
codificación de los datos resultantes.</p>
</div>
</div>
<div id="resumen" class="section level1">
<h1>Resumen</h1>
<p>En este documento se ha trabajado con una variable recodificada dummy
(satisfacción con la democracia), la que puede ser trabajada como
variable numérica para el cálculo de intervalos de confianza de
proporciones. Con esta variable se ha calculado el intervalo de
confianza de la media, que sería el de la proporción de entrevistados
que están satisfechos con la democracia. Luego, se ha descrito esta
variables por grupos de una variable de factor (consumo de información
política). Se ha presentado cómo calcular los intervalos de confianza de
la variable numérica por grupos de la variable de factor. Finalmente, se
ha presentado cómo graficar los intervalos de confianza por grupos.</p>
</div>
<div id="cálculos-incluyendo-el-efecto-de-diseño"
class="section level1">
<h1>Cálculos incluyendo el efecto de diseño</h1>
<div id="resultados-de-tolerancia-a-los-golpes-ejecutivos-ponderados"
class="section level2">
<h2>Resultados de tolerancia a los golpes ejecutivos ponderados</h2>
<p>Como se mencionó, los resultados obtenidos acerca de la tolerancia de
los golpes ejecutivos, gráfico 1.7 del reporte El Pulso de la Democracia
2021, no son iguales a los obtenidos aquí. Esto es debido a que los
cálculos de más arriba no incluye el efecto de diseño.</p>
<p>Para poder realizar los cálculos tomando en cuenta el efecto de
diseño, se puede usar la librería <code>survey</code> para definir el
diseño muestral. Primero, se tiene que adecuar la base de datos,
eliminando los valores perdidos de las variables que definen el diseño
muestral (como “weight1500”). Un paso adicional es transformar las
variables del dataframe. Esto es debido a que cuando se importan, el
sistema lee las variables como tipo “haven_labelled”, es decir, mantiene
las etiquetas de las variables, con lo que se podría producir un libro
de códigos. Esto es útil en otras ocasiones, pero genera problemas con
la librería <code>survey</code>. Para esto transformamos las variables a
otro tipo con el comando <code>sapply</code>.</p>
<pre class="r"><code>lapop21 = subset(lapop21, !is.na(weight1500))
sapply(lapop21, haven::zap_labels)</code></pre>
<p>Con la base de datos adecuada, se puede definir el diseño muestra y
se guarda en un objeto “diseno21”.</p>
<pre class="r"><code>library(survey)
diseno21 = svydesign(ids = ~upm, strata = ~strata, weights = ~weight1500, nest=TRUE, data=lapop21)</code></pre>
<p>La librería <code>survey</code> tiene comandos nativos para calcular
la media de la variable recodificada de tolerancia a los golpes
ejecutivos. Este cálculo de la media nos brinda el porcentaje de
ciudadanos en la región que son tolerantes a los golpes ejecutivos.</p>
<pre class="r"><code>svymean(~jc15ar, diseno21, na.rm=T)</code></pre>
<pre><code>##          mean     SE
## jc15ar 30.391 0.3926</code></pre>
<p>Para calcular el intervalo de confianza de esta medida se puede
anidar el comando <code>svymean</code> dentro de otro comando
<code>confint</code> que nos brinda el límite inferior y superior del
intervalo de confianza.</p>
<pre class="r"><code>confint(svymean(~jc15ar, diseno21, na.rm=T))</code></pre>
<pre><code>##           2.5 %  97.5 %
## jc15ar 29.62125 31.1601</code></pre>
<p>Para poder replicar el gráfico 1.7 requerimos el valor del porcentaje
de ciudadanos que toleran los golpes ejecutivos por páis, así como el
intervalo de confianza de cada uno. Para este cálculo, podemos usar el
comando <code>svyby</code>. Este comando requiere definir la variable a
ser calculada (<code>~jc15ar</code>), la variable que define los grupos
(<code>~paises</code>), el objeto que guarda el diseño muestral
(<code>diseno21</code>), el estadístico que se quiere calcular
(<code>svymean, na.rm=T</code>) y definir el intervalo de confianza
(<code>vartype = "ci"</code>). Estos cálculos se guardan en un objeto
“golpepond”.</p>
<pre class="r"><code>golpepond = svyby(~jc15ar, ~paises, diseno21, svymean, na.rm=T, vartype = &quot;ci&quot;)
golpepond = golpepond[-c(6,20),]</code></pre>
<p>De la misma manera que con el gráfico con los resultados no
poderados, usamos la librería <code>ggplot</code> para replicar el
gráfico 1.7. Se debe tomar en cuenta que el comando <code>svybar</code>
genera columnas con nombre diferentes a los que se generan con el
comando <code>group.CI</code> usado más arriba.</p>
<pre class="r"><code>graf3 &lt;- ggplot(golpepond, aes(x=reorder(paises, -jc15ar), y=jc15ar))+
  geom_bar(width=0.5, fill=&quot;darkslategray3&quot;, colour=&quot;#69b3a2&quot;, stat=&quot;identity&quot;)+
  geom_errorbar(aes(ymin=ci_l, ymax=ci_u), width=0.2, color=&quot;darkcyan&quot;,
                cex=0.4, linetype=3)+
  geom_text(aes(label=paste(round(jc15ar, 0), &quot;%&quot;)), vjust=-4.4, size=2.5)+
  xlab(&quot;País&quot;) + ylab(&quot;Tolerancia a golpes ejecutivos (%)&quot;)+
  ylim(0, 60)
graf3</code></pre>
<p><img
src="IC_files/figure-html/grafico%20tolerancia%20ponderada-1.png" /><!-- --></p>
<p>De esta manera se ha replicado exactamente los resultados reportados
en El Pulso de la Democracia 2021.</p>
</div>
<div id="resultados-de-satisfacción-con-la-democracia-ponderados"
class="section level2">
<h2>Resultados de satisfacción con la democracia ponderados</h2>
<p>De la misma manera que con la tolerancia a los golpes ejecutivos, se
usa la librería <code>survey</code> y el comando
<code>confint</code>junto al comando nativo <code>svymean</code>.</p>
<pre class="r"><code>library(survey)
diseno18&lt;-svydesign(ids = ~upm, strata = ~estratopri, weights = ~weight1500, nest=TRUE, data=lapop18)</code></pre>
<p>Se puede describir la variable de satisfacción con la democracia
incorporando el factor de diseño usando el comando
<code>svymean</code>.</p>
<pre class="r"><code>svymean(~pn4rr, diseno18, na.rm=T)</code></pre>
<pre><code>##         mean     SE
## pn4rr 39.459 0.3317</code></pre>
<p>Para calcular el intervalo de confianza, se tiene que anidar el
código anterior dentro del comando <code>confint</code>. Este comando
calcula el intervalo de confianza al 95% por defecto. Se podría cambiar
este valor por defecto a 99% de confianza agregando la especificación
<code>conf = 0.99</code> al comando.</p>
<pre class="r"><code>confint(svymean(~pn4rr, diseno18, na.rm=T))</code></pre>
<pre><code>##          2.5 %   97.5 %
## pn4rr 38.80884 40.10901</code></pre>
<p>También se puede calcular la media y el intervalo de confianza de
satisfacción con la democracia incorporando el efecto de diseño usando
el comando <code>svyby</code>. Dentro de este comando se especifica la
variable numérica a ser descrita (<code>~pn4rr</code>), la variable que
forma los grupos (<code>~smedia5r</code>), el diseño muestral
(<code>diseno18</code>), la función que se quiere calcular
(<code>svymean</code>), que no tome en cuenta los valores perdidos
(<code>na.rm=T</code>) y que incluya el intervalo de confianza de cada
grupo (<code>vartype="ci"</code>).</p>
<pre class="r"><code>tw.uso.weighted &lt;- svyby(~pn4rr, ~smedia5r, diseno18, svymean, na.rm=T, vartype = &quot;ci&quot;)
tw.uso.weighted</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["smedia5r"],"name":[1],"type":["fct"],"align":["left"]},{"label":["pn4rr"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["ci_l"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["ci_u"],"name":[4],"type":["dbl"],"align":["right"]}],"data":[{"1":"Alto uso","2":"39.46510","3":"36.98285","4":"41.94735","_rn_":"Alto uso"},{"1":"Bajo uso","2":"37.56570","3":"33.74961","4":"41.38179","_rn_":"Bajo uso"},{"1":"No usuario","2":"42.48075","3":"35.57877","4":"49.38274","_rn_":"No usuario"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Para poder graficar, estos cálculos se guardan en un dataframe
“tw.uso.weighted”, que incluye los datos de la media por cada grupo y el
límite inferior y superior del intervalo de confianza. De la misma
manera que con los datos que no incluyen el efecto de diseño, se usa la
librería <code>ggplot</code> y se crea un gráfico que se guarda en un
objeto “graf2”. Se usan especificaciones muy similares a los ejemplos
anteriores.</p>
<pre class="r"><code>graf4 &lt;- ggplot(tw.uso.weighted, aes(x=smedia5r, y=pn4rr))+
  geom_bar(width=0.5, fill=&quot;darkcyan&quot;, colour=&quot;black&quot;, stat=&quot;identity&quot;)+
  geom_errorbar(aes(ymin=ci_l, ymax=ci_u), width=0.2)+
  geom_text(aes(label=paste(round(pn4rr, 1), &quot;%&quot;)), vjust=-4.2, size=4)+
  xlab(&quot;Tipo de usuario de Twitter&quot;) + ylab(&quot;Satisfacción con la democracia (%)&quot;)+
  ylim(0, 50)
graf4</code></pre>
<p><img src="IC_files/figure-html/weightedbarras-1.png" /><!-- --></p>
<p>Estos resultados incluyen el efecto de diseño, pero no son
exactamente iguales a los reportados en el gráfico 3.9 del reporte El
Pulso de la Democracia de la ronda 2018/19 debido a que el cálculo de la
variable que define al tipo de usuario de Twitter es más complejo de lo
que se hace en esta sección.</p>
</div>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiSW50ZXJ2YWxvcyBkZSBjb25maWFuemEgdXNhbmRvIGVsIEJhcsOzbWV0cm8gZGUgbGFzIEFtw6lyaWNhcyIKb3V0cHV0OgogIGh0bWxfZG9jdW1lbnQ6CiAgICB0b2M6IHRydWUKICAgIHRvY19mbG9hdDogdHJ1ZQogICAgY29sbGFwc2VkOiBmYWxzZQogICAgbnVtYmVyX3NlY3Rpb25zOiBmYWxzZQogICAgdG9jX2RlcHRoOiAxCiAgICBjb2RlX2Rvd25sb2FkOiB0cnVlCiAgICB0aGVtZTogZmxhdGx5CiAgICBkZl9wcmludDogcGFnZWQKICAgIHNlbGZfY29udGFpbmVkOiBubwogICAga2VlcF9tZDogeWVzCmVkaXRvcl9vcHRpb25zOiAKICBtYXJrZG93bjogCiAgICB3cmFwOiBzZW50ZW5jZQotLS0KCmBgYHtyIHNldHVwLCBpbmNsdWRlPUZBTFNFfQprbml0cjo6b3B0c19jaHVuayRzZXQobWVzc2FnZT1GQUxTRSx3YXJuaW5nPUZBTFNFLCBjYWNoZT1UUlVFKQpgYGAKCmBgYHtjc3MgY29sb3IsIGVjaG89RkFMU0V9Ci5jb2x1bW5zIHtkaXNwbGF5OiBmbGV4O30KaDEge2NvbG9yOiAjMzM2NkNDO30KYGBgCgojIEludHJvZHVjY2nDs24KCkVuIGVzdGUgZG9jdW1lbnRvIHZlcmVtb3MgY29tbyBjb25zdHJ1aXIgaW50ZXJ2YWxvcyBkZSBjb25maWFuemEgZGUgbGEgbWVkaWEgdXNhbmRvIGxvcyBkYXRvcyBkZWwgQmFyw7NtZXRybyBkZSBsYXMgQW3DqXJpY2FzLgpQYXJhIGVzbywgdmFtb3MgYSB1c2FyIGxvcyByZXBvcnRlcyAiRWwgcHVsc28gZGUgbGEgZGVtb2NyYWNpYSIgZGUgMjAxOC8xOSwgZGlzcG9uaWJsZSBbYXF1w61dKGh0dHBzOi8vd3d3LnZhbmRlcmJpbHQuZWR1L2xhcG9wL2FiMjAxOC8yMDE4LTE5X0FtZXJpY2FzQmFyb21ldGVyX1JlZ2lvbmFsX1JlcG9ydF9TcGFuaXNoX1dfMDMuMjcuMjAucGRmKSwgeSBkZSAyMDIxLCBkaXNwb25pYmxlIFthcXXDrV0oaHR0cHM6Ly93d3cudmFuZGVyYmlsdC5lZHUvbGFwb3AvYWIyMDIxLzIwMjFfTEFQT1BfQW1lcmljYXNCYXJvbWV0ZXJfUHVsc2Vfb2ZfRGVtb2NyYWN5LnBkZikuCkVuIGxhIHJvbmRhIDIwMTgvMTksIHVuYSBkZSBsYXMgc2VjY2lvbmVzIGRlIGVzdGUgaW5mb3JtZSwgcmVwb3J0YSBsb3MgZGF0b3Mgc29icmUgcmVkZXMgc29jaWFsZXMgeSBhY3RpdHVkZXMgcG9sw610aWNhcy4KRW4gcGFydGljdWxhciwgc2UgcmVwb3J0YSwgZW4gZWwgZ3LDoWZpY28gMy45LCBlbCBncmFkbyBkZSBzYXRpc2ZhY2Npw7NuIGNvbiBsYSBkZW1vY3JhY2lhIHBvciB0aXBvIGRlIHVzdWFyaW8gZGUgcmVkZXMgc29jaWFsZXMuCkVuIGxhIHJvbmRhIDIwMjEsIHVuYSBkZSBsYXMgc2VjY2lvbmVzIHJlcG9ydGEgbG9zIGRhdG9zIHNvYnJlIGdvbHBlcyBlamVjdXRpdm9zLgpFbiBlbCBncsOhZmljbyAxLjcgc2UgcHJlc2VudGEgZWwgcG9yY2VudGFqZSBkZSBjaXVkYWRhbm9zIHF1ZSB0b2xlcmFuIGxvcyBnb2xwZXMgZWplY3V0aXZvcyBwb3IgcGHDrXMuCkVuIGFtYm9zIGNhc29zLCBsb3MgcmVzdWx0YWRvcyBpbmNsdXllbiBsYXMgZXN0aW1hY2lvbmVzIHB1bnR1YWxlcyB5IGxvcyBpbnRlcnZhbG9zIGRlIGNvbmZpYW56YS4KCiMgU29icmUgbGFzIGJhc2VzIGRlIGRhdG9zCgpMb3MgZGF0b3MgcXVlIHZhbW9zIGEgdXNhciBkZWJlbiBjaXRhcnNlIGRlIGxhIHNpZ3VpZW50ZSBtYW5lcmE6IEZ1ZW50ZTogQmFyw7NtZXRybyBkZSBsYXMgQW3DqXJpY2FzIHBvciBlbCBQcm95ZWN0byBkZSBPcGluacOzbiBQw7pibGljYSBkZSBBbcOpcmljYSBMYXRpbmEgKExBUE9QKSwgd3d3dy5MYXBvcFN1cnZleXMub3JnLgpFbiBlc3RlIGRvY3VtZW50byBzZSBjYXJnYSB1bmEgYmFzZSBkZSBkYXRvcyByZWNvcnRhZGEuCkVzdGEgYmFzZSBkZSBkYXRvcyBzZSBlbmN1ZW50cmEgYWxvamFkYSBlbiBlbCByZXBvc2l0b3JpbyAibWF0ZXJpYWxzX2VkdSIgZGUgbGEgY3VlbnRhIGRlIExBUE9QIGVuIEdpdEh1Yi4KU2UgcmVjb21pZW5kbyBsaW1waWFyIGVsIEVudmlyb25tZW50IGFudGVzIGRlIHByb2NlZGVyIGNvbiBlc3RhIHNlY2Npw7NuLgoKTWVkaWFudGUgbGEgbGlicmVyw61hIGByaW9gIHkgZWwgY29tYW5kbyBgaW1wb3J0YCBzZSBwdWVkZSBpbXBvcnRhciBlc3RhIGJhc2UgZGUgZGF0b3MgZGVzZGUgZXN0ZSByZXBvc2l0b3Jpby4KQWRlbcOhcywgc2Ugc2VsZWNjaW9uYW4gbG9zIGRhdG9zIGRlIHBhw61zZXMgY29uIGPDs2RpZ29zIG1lbm9yZXMgbyBpZ3VhbGVzIGEgMzUsIGVzIGRlY2lyLCBzZSBlbGltaW5hIGxhcyBvYnNlcnZhY2lvbmVzIGRlIEVzdGFkb3MgVW5pZG9zIHkgQ2FuYWTDoS4KCmBgYHtyIGJhc2V9CmxpYnJhcnkocmlvKQpsYXBvcDE4IDwtIGltcG9ydCgiaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9sYXBvcC1jZW50cmFsL21hdGVyaWFsc19lZHUvbWFpbi9MQVBPUF9BQl9NZXJnZV8yMDE4X3YxLjAuc2F2IikKbGFwb3AxOCA8LSBzdWJzZXQobGFwb3AxOCwgcGFpczw9MzUpCmBgYAoKVGFtYmnDqW4gY2FyZ2Ftb3MgbGEgYmFzZSBkZSBkYXRvcyBkZSBsYSByb25kYSAyMDIxLgoKYGBge3IgYmFzZTIxfQpsYXBvcDIxID0gaW1wb3J0KCJsYXBvcDIxLlJEYXRhIikKbGFwb3AyMSA8LSBzdWJzZXQobGFwb3AyMSwgcGFpczw9MzUpCmBgYAoKIyBUb2xlcmFuY2lhIGEgbG9zIGdvbHBlcyBlamVjdXRpdm9zCgpFbCBncsOhZmljbyAxLjcgZGVsIHJlcG9ydGUgRWwgcHVsc28gZGUgbGEgRGVtb2NyYWNpYSBwYXJhIGxhIHJvbmRhIGRlbCBCYXLDs21ldHJvIGRlIGxhcyBBbcOpcmljYXMgMjAyMSBwcmVzZW50YSBsb3MgcmVzdWx0YWRvcyBkZWwgcG9yY2VudGFqZSBkZSBjaXVkYWRhbm9zIHF1ZSB0b2xlcmEgdW4gZ29scGUgZWplY3V0aXZvLgpFc3RlIGdyw6FmaWNvLCBhZGVtw6FzLCBwcmVzZW50ZSBlbCBpbnRlcnZhbG8gZGUgY29uZmlhbnphIGFsIDk1JSBkZSBlc3RlIHBvcmNlbnRhamUgZW4gY2FkYSBwYcOtcy4KCiFbXShGaWd1cmUxLjcucG5nKXt3aWR0aD0iNTY0In0KCkxhIHZhcmlhYmxlIHBhcmEgY29uc3RydWlyIGVzdGUgZ3LDoWZpY28gZXMgImpjMTVhIiBxdWUgZXN0w6EgZnJhc2VhZGE6IMK/Q3JlZSB1c3RlZCBxdWUgY3VhbmRvIGVsIHBhw61zIGVuZnJlbnRhIG1vbWVudG9zIG11eSBkaWbDrWNpbGVzLCBzZSBqdXN0aWZpY2EgcXVlIGVsIHByZXNpZGVudGUgZGVsIHBhw61zIGNpZXJyZSBlbCBDb25ncmVzby9Bc2FtYmxlYSB5IGdvYmllcm5vIHNpbiBDb25ncmVzby9Bc2FtYmxlYT8KTGFzIG9wY2lvbmVzIGRlIHJlc3B1ZXN0YSBzb246CgoxLiAgU8OtIHNlIGp1c3RpZmljYQoyLiAgTm8gc2UganVzdGlmaWNhCgojIyBEZXNjcmliaWVuZG8gbGEgdG9sZXJhbmNpYSBhIGxvcyBnb2xwZXMgZWplY3V0aXZvcwoKUGFyYSBjYWxjdWxhcyBsb3MgcG9yY2VudGFqZXMgZGUgY2l1ZGFkYW5vcyBxdWUganVzdGlmaWNhbiBvIHRvbGVyYW4gbG9zIGdvbHBlcyBlamVjdXRpdm9zIHNlIHRpZW5lIHF1ZSByZWNvZGlmaWNhciBlc3RhIHZhcmlhYmxlLCBkZSB0YWwgbWFuZXJhIHF1ZSBhcXVlbGxvcyBxdWUganVzdGlmaWNhbiB0ZW5nYW4gZWwgdmFsb3IgMTAwIHkgbG9zIHF1ZSBubyBqdXN0aWZpY2FuLCBlbCB2YWxvciAwLgpFbiBlc3RlIGNhc28gc2UgdXNhIGVsIGNvbWFuZG8gYHJlY29kZWAgeSBzZSB0YWJ1bGEsIG1lZGlhbnRlIGB0YWJsZWAsIHBhcmEgdmVyaWZpY2FyIGxhIHJlY29kaWZpY2FjacOzbi4KCmBgYHtyIHRvbGVyYW5jaWF9CmxhcG9wMjEkamMxNWFyIDwtIGNhcjo6cmVjb2RlKGxhcG9wMjEkamMxNWEsICIxPTEwMDsgMj0wIikKdGFibGUobGFwb3AyMSRqYzE1YXIpCmBgYAoKUGFyYSBjYWxjdWxhciBlbCBwb3JjZW50YWplIGRlIGNpdWRhZGFub3MgcXVlIHRvbGVyYW4gbG9zIGdvbHBlcyBlamVjdXRpdm9zIHNlIHB1ZWRlIHVzYXIgbG9zIGNvbWFuZG9zIGB0YWJsZWAgeSBgcHJvcC50YWJsZWAuCkxhIG51ZXZhIHZhcmlhYmxlICJqYzE1YXIiIGVzIHVuYSB2YXJpYWJsZSBkdW1teS4KRW4gZXN0ZSB0aXBvIGRlIHZhcmlhYmxlcywgbGEgbWVkaWEgY29ycmVzcG9uZGUgYSBsYSBwcm9wb3JjacOzbiBkZSByZXNwdWVzdGFzIDEwMC4KRXMgZGVjaXIsIHNpIGNhbGN1bGFtb3MgbGEgbWVkaWEgZGUgZXN0YSB2YXJpYWJsZSwgc2UgZXN0w6EgY2FsY3VsYW5kbyBlbCBwb3JjZW50YWplIHBhcmEgdG9kb3MgbG9zIGVudHJldmlzdGFkb3MuCkVuIGVzdGEgc2VjY2nDs24gdmFtb3MgYSB0cmF0YXIgYSBlc3RhIHZhcmlhYmxlIGNvbW8gc2kgZnVlcmEgdW5hIHZhcmlhYmxlIG51bcOpcmljYS4KRW4gc2VudGlkbyBlc3RyaWN0byBlcyB1bmEgdmFyaWFibGUgY2F0ZWfDs3JpY2Egbm9taW5hbC4KTG9zIGPDoWxjdWxvcyBkZSBkZXN2aWFjaW9uZXMgZXN0w6FuZGFyIHkgbHVlZ28gZGUgaW50ZXJ2YWxvcyBkZSBjb25maWFuemEsIHBvciBsbyB0YW50bywgc29uIHJlZmVyZW5jaWFsZXMuCgpFbCByZXN1bHRhZG8gaW5kaWNhIHF1ZSBlbiB0b2RhIGxhIG11ZXN0cmEsIGVsIHBvcmNlbnRhamUgZGUgY2l1ZGFkYW5vcyBxdWUgdG9sZXJhbiBsb3MgZ29scGVzIGVqZWN1dGl2b3MgZXMgZGUgMjguNyUuCgpgYGB7ciByZXN1bWVuIHRvbGVyYW5jaWF9CnN1bW1hcnkobGFwb3AyMSRqYzE1YXIpCmBgYAoKIyMgSW50ZXJ2YWxvcyBkZSBjb25maWFuemEgZGUgdG9sZXJhbmNpYSBhIGxvcyBnb2xwZXMgZWplY3V0aXZvcwoKUGFyYSBjYWxjdWxhciBlbCBpbnRlcnZhbG8gZGUgY29uZmlhbnphIGFsIDk1JSBkZSBlc3RlIHBvcmNlbnRhamUsIHNlIHB1ZWRlIHVzYXIgZWwgY29tYW5kbyBgdC50ZXN0YCBvIGxhIGxpYnJlcsOtYSBgbHNyYCwgcXVlIHRpZW5lIGVsIGNvbWFuZG8gYGNpTWVhbmAuCkVuIGFtYm9zIGNhc29zLCBlbCByZXN1bHRhZG8gbm9zIGluZGljYSBxdWUgZWwgcG9yY2VudGFqZSBkZSBjaXVkYWRhbm9zIHF1ZSB0b2xlcmEgbG9zIGdvbHBlcyBlamVjdXRpdm9zIGVuIGxhIHJlZ2nDs24gZXN0w6EgZW50cmUgMjglIHkgMjkuMyUuCgpgYGB7ciBpYyB0b2xlcmFuY2lhfQp0LnRlc3QobGFwb3AyMSRqYzE1YXIpCmxpYnJhcnkobHNyKQpjaU1lYW4oYXMubnVtZXJpYyhsYXBvcDIxJGpjMTVhciksIG5hLnJtPVQpCmBgYAoKIyMgVG9sZXJhbmNpYSBhIGxvcyBnb2xwZXMgZWplY3V0aXZvcyBwb3IgcGHDrXMKCkVsIGdyw6FmaWNvIDEuNyBtdWVzdHJhIGVsIHBvcmNlbnRhamUgZGUgY2l1ZGFkYW5vcyBxdWUgdG9sZXJhbiBsb3MgZ29scGVzIGVqZWN1dGl2b3MgcG9yIHBhw61zLgpQYXJhIHJlcGxpY2FyIGVzdGUgZ3LDoWZpY28sIHByaW1lcm8gdGVuZW1vcyBxdWUgZGVmaW5pciBxdWUgbGEgdmFyaWFibGUgInBhaXMiIGVzIGRlIHRpcG8gZmFjdG9yLgpTZSBndWFyZGEgZXN0ZSBjYW1iaW8gZW4gdW5hIG51ZXZhIHZhcmlhYmxlICJwYWlzZXMiLCBsYSBxdWUgc2UgZXRpcXVldGEgY29uIGxhcyBzaWdsYXMgZGUgY2FkYSBwYcOtcy4KCmBgYHtyIHBhaXN9CmxhcG9wMjEkcGFpc2VzIDwtIGFzLmZhY3RvcihsYXBvcDIxJHBhaXMpCmxldmVscyhsYXBvcDIxJHBhaXNlcykgPC0gYygiTVgiLCAiR1QiLCAiU1YiLCAiSE4iLCAiTkkiLCAiQ1IiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgIlBOIiwgIkNPIiwgIkVDIiwgIkJPIiwgIlBFIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICJQWSIsICJDTCIsICJVWSIsICJCUiIsICJBUiIsICJETyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAiSFQiLCAiSkEiLCAiR1UiKQp0YWJsZShsYXBvcDIxJHBhaXNlcykKYGBgCgpQYXJhIGNhbGN1bGFyIGVzdG9zIHBvcmNlbnRhamVzIHBvciBwYcOtcywgc2UgcHVlZGUgdXNhciB2YXJpYXMgYWx0ZXJuYXRpdmFzLgpQb3IgZWplbXBsbywgZWwgY29tYW5kbyBgdGFwcGx5YCBwZXJtaXRlIGNhbGN1bGFyIGxhIG1lZGlhIGRlIHVuYSB2YXJpYWJsZSBwb3IgZ3J1cG9zIGRlIG90cmEgdmFyaWFibGUuCgpgYGB7ciB0b2xlcmFuY2lhIHBvciBwYWlzfQp0YXBwbHkobGFwb3AyMSRqYzE1YXIsIGxhcG9wMjEkcGFpc2VzLCBtZWFuLCBuYS5ybT1UKQoKYGBgCgpPdHJhIGZvcm1hIGVzIHVzYXIgbGFzIGxpYnJlcsOtYXMgYHBseXJgIHkgYGRwbHlyYCBxdWUgaW5jbHV5ZSBlbCBjb21hbmRvIGBkZHBseWAuCkVzdGUgY29tYW5kbyByZXF1aWVyZSBxdWUgc2UgZGVmaW5hIGVsIGRhdGFmcmFtZSAibGFwb3AyMSIsIGxhIHZhcmlhYmxlIGRlIGFncnVwYW1pZW50byAicGFpc2VzIiB5IGx1ZWdvIGxhcyBmdW5jaW9uZXMgcXVlIHNlIHJlcXVpZXJlIGVuIGNhZGEgZ3J1cG8sIHF1ZSBlbiBlc3RlIGNhc28gc29uICJtZWFuIiB5ICJzZCIuCgpgYGB7ciB0b2xlcmFuY2lhIHBvciBwYWlzIDJ9CmxpYnJhcnkocGx5cikKbGlicmFyeShkcGx5cikKZGRwbHkobGFwb3AyMSwgInBhaXNlcyIsIHN1bW1hcmlzZSwgbWVhbj1tZWFuKGpjMTVhciwgbmEucm09VCksIHNkPXNkKGpjMTVhciwgbmEucm09VCkpCmBgYAoKQ29tbyBzZSBvYnNlcnZhIGVuIGxhIHRhYmxhLCBubyBoYXkgZGF0b3MgcGFyYSBDb3N0YSBSaWNhLCBuaSBwYXJhIEd1eWFuYS4KQ29uIGVsIGPDoWxjdWxvIGRlIGxhIGRlc3ZpYWNpw7NuIGVzdMOhbmRhciwgc2UgcG9kcsOtYSBjYWxjdWxhciBlbCBsw61taXRlIGluZmVyaW9yIHkgc3VwZXJpb3IgZGVsIGludGVydmFsbyBkZSBjb25maWFuemEuCgpFc3RvIHNlIHB1ZWRlIGhhY2VyIGRlIG1hbmVyYSBkaXJlY3RhIGNvbiBsYSBsaWJyZXLDrWEgYFJtaXNjYC4KRXN0YSBsaWJyZXLDrWEgdGllbmUgZWwgY29tYW5kbyBgZ3JvdXAuQ0lgLCBxdWUgY2FsY3VsYSBsYSBtZWRpYSwgZWwgbMOtbWl0ZSBpbmZlcmlvciB5IHN1cGVyaW9yIGRlIHVuYSB2YXJpYWJsZSBwb3IgZ3J1cG9zIGRlIG90cmEgdmFyaWFibGUuCkVzdGEgdGFibGEgc2UgZ3VhcmRhIGVuIHVuIG9iamV0byBsbGFtYWRvICJnb2xwZSIuCkVzdGUgY29tYW5kbyBubyBpbmNsdXllIGxhcyBmaWxhcyBkZSBsb3MgcGHDrXNlcyBkb25kZSBubyBoYXkgZGF0b3MsIHBvciBsbyBxdWUgbm8gaGF5IGZpbGFzIGRlIENvc3RhIFJpY2EgbmkgZGUgR3V5YW5hLgoKYGBge3IgaWMgdG9sZXJhbmNpYSBwb3IgcGFpc30KbGlicmFyeShSbWlzYykKZ29scGUgPC0gZ3JvdXAuQ0koamMxNWFyfnBhaXNlcywgbGFwb3AyMSkKZ29scGUKYGBgCgpDb24gZXN0YSB0YWJsYSBwb2RlbW9zIHJlcGxpY2FyIGVsIGdyw6FmaWNvIDEuNyBjb24gbGEgbGlicmVyw61hIGBnZ3Bsb3QyYC4KUGFyYSBpbmNsdWlyIGxvcyBpbnRlcnZhbG9zIGRlIGNvbmZpYW56YSBzZSB0aWVuZSBxdWUgYWdyZWdhciBsYSBlc3BlY2lmaWNhY2nDs24gYGdlb21fZXJyb3JiYXIoKWAuCkxhIHRhYmxhICJnb2xwZSIgdGllbmUgZWwgZGF0byBkZSAieW1pbiIgZW4gbGEgY29sdW1uYSAiamMxNWFyLmxvd2VyIiB5IGVsIGRhdG8gZGUgInltYXgiIGVuIGxhIGNvbHVtbmEgImpjMTVhci51cHBlciIuCkVzdG9zIGRhdG9zIHNlIGRlYmVuIGluZ3Jlc2FyIGVuIGxhIGVzcGVjaWZpY2FjacOzbiBgYWVzYCBkZW50cm8gZGUgYGdlb21fZXJyb3JiYXJgLgpBZGVtw6FzLCBzZSB0aWVuZSBjb21vIG9wY2lvbmVzIGB3aWR0aGAgcGFyYSBlc3BlY2lmaWNhciBlbCBhbmNobyBkZSBsYXMgYmlnb3RlcyBkZSBsYXMgYmFycmFzIGRlIGVycm9yLCBgY29sb3JgIHBhcmEgZXNwZWNpZmljYXIgZWwgY29sb3IsIGBjZXhgIHBhcmEgZXNwZWNpZmljYXIgZWwgYW5jaG8gZGUgbGFzIGzDrW5lYXMgeSBgbGluZXR5cGVgIHBhcmEgZXNwZWNpZmljYXIgZWwgdGlwbyBkZSBsw61uZWFzLCBlbiBlc3RlIGNhc28gcHVudHVhZGFzLgoKUGFyYSBwb2RlciBvcmRlbmFyIGxhcyBiYXJyYXMgZGUgYWN1ZXJkbyBhbCB2YWxvciBkZSBsYSB2YXJpYWJsZSwgc2UgcHVlZGUgdXNhciBsYSBlc3BlY2lmaWNhY2nDs24gYHJlb3JkZXIoZ3J1cG8sIHZhcmlhYmxlKWAgZGVudHJvIGRlIGxhIGVzcGVjaWZpY2FjacOzbiBgYWVzYCBkZSBgZ2dwbG90YC4KCmBgYHtyIGdyYWZpY28gdG9sZXJhbmNpYSBwb3IgcGFpc30KbGlicmFyeShnZ3Bsb3QyKQpncmFmMSA8LSBnZ3Bsb3QoZ29scGUsIGFlcyh4PXJlb3JkZXIocGFpc2VzLCAtamMxNWFyLm1lYW4pLCB5PWpjMTVhci5tZWFuKSkrCiAgZ2VvbV9iYXIod2lkdGg9MC41LCBmaWxsPSJkYXJrc2xhdGVncmF5MyIsIGNvbG91cj0iIzY5YjNhMiIsIHN0YXQ9ImlkZW50aXR5IikrCiAgZ2VvbV9lcnJvcmJhcihhZXMoeW1pbj1qYzE1YXIubG93ZXIsIHltYXg9amMxNWFyLnVwcGVyKSwgd2lkdGg9MC40LCAKICAgICAgICAgICAgICAgIGNvbG9yPSJkYXJrY3lhbiIsIGNleD0wLjQsIGxpbmV0eXBlPTMpKwogIGdlb21fdGV4dChhZXMobGFiZWw9cGFzdGUocm91bmQoamMxNWFyLm1lYW4sIDEpLCAiJSIpKSwgdmp1c3Q9LTQuNCwgc2l6ZT0yLjUpKwogIHhsYWIoIlBhw61zIikgKyB5bGFiKCJUb2xlcmFuY2lhIGEgZ29scGVzIGVqZWN1dGl2b3MgKCUpIikrCiAgeWxpbSgwLCA2MCkKZ3JhZjEKYGBgCgpFc3RvcyBkYXRvcywgc2luIGVtYmFyZ28sIG5vIHNvbiBleGFjdGFtZW50ZSBpZ3VhbGVzIGEgbG9zIHByZXNlbnRhZG9zIGVuIGVsIGdyw6FmaWNvIDEuNyBkZWJpZG8gYSBxdWUgZXN0b3MgY8OhbGN1bG9zIG5vIGluY2x1eWVuIGVsIGVmZWN0byBkZSBkaXNlw7FvLgpNw6FzIGFkZWxhbnRlLCBzZSB2ZXLDoSBjw7NtbyBpbmNsdWlyIGVsIGVmZWN0byBkZSBkaXNlw7FvIHBhcmEgcmVwbGljYXIgZWwgZ3LDoWZpY28gZXhhY3RhbWVudGUuCgojIFNhdGlzZmFjY2nDs24gY29uIGxhIGRlbW9jcmFjaWEKCkVsIGdyw6FmaWNvIDMuOSBkZWwgcmVwb3J0ZSBFbCBQdWxzbyBkZSBsYSBEZW1vY3JhY2lhIGRlIGxhIHJvbmRhIDIwMTgvMTkgcHJlc2VudGEgZWwgcG9yY2VudGFqZSBkZSBlbnRyZXZpc3RhZG9zIHF1ZSBlc3TDoSBzYXRpc2ZlY2hvIGNvbiBsYSBkZW1vY3JhY2lhIHBvciB0aXBvIGRlIHVzdWFyaW9zIGRlIHJlZGVzIHNvY2lhbGVzLgoKIVtdKEdyYWYzLjkucG5nKXt3aWR0aD0iNDEzIn0KCkxhIHZhcmlhYmxlIHNhdGlzZmFjY2nDs24gY29uIGxhIGRlbW9jcmFjaWEgc2UgbGxhbWEgInBuNCIgeSBlc3TDoSBjb2RpZmljYWRhIGRlIGxhIHNpZ3VpZW50ZSBtYW5lcmE6CgoxLiAgTXV5IHNhdGlzZmVjaG8KMi4gIFNhdGlzZmVjaG8KMy4gIEluc2F0aXNmZWNobwo0LiAgTXV5IGluc2F0aXNmZWNobwoKTGEgbm90YSAyMSBkZSBlc3RlIHJlcG9ydGUgaW5kaWNhIHF1ZSAiU2UgY29kaWZpY2EgYSBsb3MgZW50cmV2aXN0YWRvcyBxdWUgc2VsZWNjaW9uYW4gKDEpIG8gKDIpIGNvbW8gc2F0aXNmZWNob3MgY29uIGxhIGRlbW9jcmFjaWEiLgpQb3IgbG8gdGFudG8sIHNlIHRpZW5lIHF1ZSByZWNvZGlmaWNhciBlc3RhIHZhcmlhYmxlLgpFbiBlc3RlIGNhc28gc2UgdXNhIGVsIGNvbWFuZG8gYHJlY29kZWAgeSBzZSB0YWJ1bGEsIG1lZGlhbnRlIGB0YWJsZWAsIHBhcmEgdmVyaWZpY2FyIGxhIHJlY29kaWZpY2FjacOzbi4KCmBgYHtyIHJlY29kaWZpY2FyIHNhdGlzZmFjY2lvbiwgbWVzc2FnZT1GQUxTRSwgd2FybmluZz1GQUxTRX0KbGlicmFyeShjYXIpCnRhYmxlKGxhcG9wMTgkcG40KQpsYXBvcDE4JHBuNHJyIDwtIGNhcjo6cmVjb2RlKGxhcG9wMTgkcG40LCAiMToyPTEwMDsgMzo0PTAiKQp0YWJsZShsYXBvcDE4JHBuNHJyKQpgYGAKCkxhIG51ZXZhIHZhcmlhYmxlICJwbjRyciIgZXMgdW5hIHZhcmlhYmxlIGR1bW15LgpFbiBlc3RlIHRpcG8gZGUgdmFyaWFibGVzLCBsYSBtZWRpYSBjb3JyZXNwb25kZSBhIGxhIHByb3BvcmNpw7NuIGRlIHJlc3B1ZXN0YXMgMTAwLgpFcyBkZWNpciwgc2kgY2FsY3VsYW1vcyBsYSBtZWRpYSBkZSBlc3RhIHZhcmlhYmxlLCBzZSBlc3TDoSBjYWxjdWxhbmRvIGVsIHBvcmNlbnRhamUgcGFyYSB0b2RvcyBsb3MgZW50cmV2aXN0YWRvcy4KRW4gZXN0YSBzZWNjacOzbiB2YW1vcyBhIHRyYXRhciBhIGVzdGEgdmFyaWFibGUgY29tbyBzaSBmdWVyYSB1bmEgdmFyaWFibGUgbnVtw6lyaWNhLgpFbiBzZW50aWRvIGVzdHJpY3RvIGVzIHVuYSB2YXJpYWJsZSBjYXRlZ8OzcmljYSBub21pbmFsLgpMb3MgY8OhbGN1bG9zIGRlIGRlc3ZpYWNpb25lcyBlc3TDoW5kYXIgeSBsdWVnbyBkZSBpbnRlcnZhbG9zIGRlIGNvbmZpYW56YSwgcG9yIGxvIHRhbnRvLCBzb24gcmVmZXJlbmNpYWxlcy4KCmBgYHtyIGRlc2NyaWJpciBzYXRpc2ZhY2Npb259CnN1bW1hcnkobGFwb3AxOCRwbjRycikKYGBgCgpFc3RvcyByZXN1bHRhZG9zIG11ZXN0cmFuIHVuYSBtZWRpYSBkZSAzOS41LCBlcyBkZWNpciBlbCAzOS41JSBkZSBsb3MgZW50cmV2aXN0YWRvcyBlc3TDoW4gc2F0aXNmZWNob3MgY29uIGxhIGRlbW9jcmFjaWEuClNlIHB1ZWRlIGNhbGN1bGFyIHRhbWJpw6luIGVsIGludGVydmFsbyBkZSBjb25maWFuemEgZGUgZXN0YSB2YXJpYWJsZSBkZSB2YXJpYXMgZm9ybWFzLgpVbmEgcHJpbWVyYSBlcyBtZWRpYW50ZSBsYSBwcnVlYmEgdCBkZSB1bmEgbXVlc3RyYSwgdXNhbmRvIGVsIGNvbWFuZG8gYHQudGVzdGAuCk90cmEgZm9ybWEgZXMgdXNhbmRvIGVsIGNvbWFuZG8gYGNpTWVhbmAgZGUgbGEgbGlicmVyw61hIGBsc3JgLgoKYGBge3IgaWMgc2F0aXNmYWNjaW9ufQp0LnRlc3QobGFwb3AxOCRwbjRycikKbGlicmFyeShsc3IpCmNpTWVhbihsYXBvcDE4JHBuNHJyLCBuYS5ybT1UKQpgYGAKCkVzdG9zIHJlc3VsdGFkb3MgaW5kaWNhbiBxdWUgZWwgaW50ZXJ2YWxvIGRlIGNvbmZpYW56YSBkZSBsYSBtZWRpYSBkZSBzYXRpc2ZhY2Npw7NuIGNvbiBsYSBkZW1vY3JhY2lhIHZhcsOtYSBlbnRyZSAzOC45JSB5IDQwLjElIGNvbiA5NSUgZGUgY29uZmlhbnphLgpTZSBwb2Ryw61hIGNhbWJpYXIgZXN0ZSB2YWxvciBwb3IgZGVmZWN0byBhIDk5JSBkZSBjb25maWFuemEgYWdyZWdhbmRvIGxhIGVzcGVjaWZpY2FjacOzbiBgY29uZiA9IDAuOTlgIGFsIGNvbWFuZG8gYGNpTWVhbmAuCgojIyBTYXRpc2ZhY2Npw7NuIGNvbiBsYSBkZW1vY3JhY2lhIHBvciBncnVwb3MgZGUgY29uc3VtbyBkZSBpbmZvcm1hY2nDs24gZW4gcmVkZXMgc29jaWFsZXMKCkVsIGluZm9ybWUgdXNhIHVuYSB2YXJpYWJsZSBxdWUgbWlkZSBsYSAiZXhwb3NpY2nDs24gZnJlY3VlbnRlIGEgaW5mb3JtYWNpw7NuIHBvbMOtdGljYSIuCkVzdGEgdmFyaWFibGUgc2UgY29uc3RydXllIGRlIHVuYSBtYW5lcmEgY29tcGxlamEsIHNvYnJlIGxhIGJhc2UgZGUgbGFzIDMgcmVkZXMgc29jaWFsZXMgcG9yIGxhcyBxdWUgc2UgcHJlZ3VudGEuCkVuIGVzdGUgY2FzbyB2YW1vcyBhIGVtcGV6YXIgY29uIHVuYSByZWNvZGlmaWNhY2nDs24gbcOhcyBzaW1wbGUgcGFyYSByZWNyZWFyIGxvcyBpbnRlcnZhbG9zIGRlIGNvbmZpYW56YSBkZSBsYSB2YXJpYWJsZSAic2F0aXNmYWNjacOzbiBkZSBsYSBkZW1vY3JhY2lhIiBwb3IgZ3J1cG8gZGUgZnJlY3VlbmNpYSBkZSBjb25zdW1vIGRlIGluZm9ybWFjacOzbiBkZSBjYWRhIHJlZCBzb2NpYWwuCkx1ZWdvIHNlIHByb2NlZGVyw6EgYSByZXBsaWNhciBsYSB2YXJpYWJsZSBxdWUgc2UgdXNhIGVuIGVsIHJlcG9ydGUuCkxhIGZyZWN1ZW5jaWEgZGUgY29uc3VtbyBkZSBpbmZvcm1hY2nDs24gKHZhcmlhYmxlcyAic21lZGlhMiIgcGFyYSBGYWNlYm9vaywgInNtZWRpYTUiIHBhcmEgVHdpdHRlciB5ICJzbWVkaWE4IiBwYXJhIFdoYXRzYXBwKSBkZSBjYWRhIHJlZCBzb2NpYWwgc2UgbWlkZSBlbiBsYSBzaWd1aWVudGUgZXNjYWxhOgoKMS4gIERpYXJpYW1lbnRlCjIuICBBbGd1bmFzIHZlY2VzIGEgbGEgc2VtYW5hCjMuICBBbGd1bmFzIHZlY2VzIGFsIG1lcwo0LiAgQWxndW5hcyB2ZWNlcyBhbCBhw7FvCjUuICBOdW5jYQoKVmFtb3MgYSByZWNvZGlmaWNhciBlc3RhcyB2YXJpYWJsZXMgZGUgdGFsIG1hbmVyYSBxdWUgYXF1ZWxsb3MgcXVlIHJlc3BvbmRlbiBkaWFyaWFtZW50ZSBvIGFsZ3VuYXMgdmVjZXMgYSBsYSBzZW1hbmEgc2Vyw6FuIGNsYXNpZmljYWRvcyBjb21vIGRlICJhbHRvIHVzbyIsIGFxdWVsbG9zIHF1ZSByZXNwb25kZW4gZGVsIDMgYWwgNCBzZXLDoW4gY2xhc2lmaWNhZG9zIGNvbW8gZGUgImJham8gdXNvIiB5IGFxdWVsbG9zIHF1ZSByZXNwb25kZW4gIm51bmNhIiBzZXLDoW4gY2xhc2lmaWNhZG9zIGNvbW8gIm5vIHVzdWFyaW9zIi4KVW4gZXNxdWVtYSBzaW1pbGFyIGRlIGNsYXNpZmljYWNpw7NuIHNlIHVzYSBwYXJhIGRlZmluaXIgYSBsb3MgdXN1YXJpb3MgZGUgbGFzIDMgcmVkZXMgc29jaWFsZXMuCkxhcyBudWV2YXMgdmFyaWFibGVzIHJlY29kaWZpY2FkYXMsIHNlIGNvbnZpZXJ0ZW4gYSBmYWN0b3IgeSBzZSBldGlxdWV0YW4uCgpgYGB7ciByZWNvZGlmaWNhY2lvbiByZWRlc30KdGFibGUobGFwb3AxOCRzbWVkaWEyKQp0YWJsZShsYXBvcDE4JHNtZWRpYTUpCnRhYmxlKGxhcG9wMTgkc21lZGlhOCkKbGFwb3AxOCRzbWVkaWEyciA8LSBjYXI6OnJlY29kZShsYXBvcDE4JHNtZWRpYTIsICIxOjI9MTsgMzo0PTI7IDU9MyIpCmxhcG9wMTgkc21lZGlhNXIgPC0gY2FyOjpyZWNvZGUobGFwb3AxOCRzbWVkaWE1LCAiMToyPTE7IDM6ND0yOyA1PTMiKQpsYXBvcDE4JHNtZWRpYThyIDwtIGNhcjo6cmVjb2RlKGxhcG9wMTgkc21lZGlhOCwgIjE6Mj0xOyAzOjQ9MjsgNT0zIikKbGFwb3AxOCRzbWVkaWEyciA8LSBhcy5mYWN0b3IobGFwb3AxOCRzbWVkaWEycikKbGFwb3AxOCRzbWVkaWE1ciA8LSBhcy5mYWN0b3IobGFwb3AxOCRzbWVkaWE1cikKbGFwb3AxOCRzbWVkaWE4ciA8LSBhcy5mYWN0b3IobGFwb3AxOCRzbWVkaWE4cikKbGV2ZWxzKGxhcG9wMTgkc21lZGlhMnIpIDwtIGMoIkFsdG8gdXNvIiwgIkJham8gdXNvIiwgIk5vIHVzdWFyaW8iKQpsZXZlbHMobGFwb3AxOCRzbWVkaWE1cikgPC0gYygiQWx0byB1c28iLCAiQmFqbyB1c28iLCAiTm8gdXN1YXJpbyIpCmxldmVscyhsYXBvcDE4JHNtZWRpYThyKSA8LSBjKCJBbHRvIHVzbyIsICJCYWpvIHVzbyIsICJObyB1c3VhcmlvIikKdGFibGUobGFwb3AxOCRzbWVkaWEycikKdGFibGUobGFwb3AxOCRzbWVkaWE1cikKdGFibGUobGFwb3AxOCRzbWVkaWE4cikKYGBgCgpDb24gZXN0YXMgdmFyaWFibGVzIHJlY29kaWZpY2FkYXMsIHNlIHB1ZWRlIGNhbGN1bGFyIGxhcyBtZWRpYXMgKHF1ZSBzb24gbG9zIHBvcmNlbnRhamVzKSBkZSBzYXRpc2ZhY2Npw7NuIGNvbiBsYSBkZW1vY3JhY2lhIHBvciBjYWRhIGdydXBvIGRlIGNvbnN1bW8gZGUgaW5mb3JtYWNpw7NuIGVuIHJlZGVzIHNvY2lhbGVzLgpFc3RvIHNlIHB1ZWRlIGhhY2VyIGRlIG3Dumx0aXBsZXMgbWFuZXJhcy4KU2kgc2UgcmVxdWllcmUgY29tcGFyYXIgbGFzIG1lZGlhcywgc2UgcHVlZGUgdXNhciBlbCBjb21hbmRvIGB0YXBwbHlgLgoKYGBge3IgbWVkaWFwb3JyZWRlc30KdGFwcGx5KGxhcG9wMTgkcG40cnIsIGxhcG9wMTgkc21lZGlhMnIsIG1lYW4sIG5hLnJtPVQpICNGYWNlYm9vawp0YXBwbHkobGFwb3AxOCRwbjRyciwgbGFwb3AxOCRzbWVkaWE1ciwgbWVhbiwgbmEucm09VCkgI1R3aXR0ZXIKdGFwcGx5KGxhcG9wMTgkcG40cnIsIGxhcG9wMTgkc21lZGlhOHIsIG1lYW4sIG5hLnJtPVQpICNXaGF0c2FwcApgYGAKCk90cmEgb3BjacOzbiBxdWUgcHVlZGUgcHJlc2VudGFyIHRhbnRvIGxhIG1lZGlhIGNvbW8gbGEgZGVzdmlhY2nDs24gZXN0w6FuZGFyIGVzIG1lZGlhbnRlIGxhIGxpYnJlcsOtYSBgcGx5cmAgeSBlbCBjb21hbmRvIGBkZHBseWAuCkVsIGPDs2RpZ28gc29sbyBwYXJhIEZhY2Vib29rIHNlcsOtYToKCmBgYHtyIG1lZGlhcG9ycmVkZXMyLCBtZXNzYWdlPUZBTFNFLCB3YXJuaW5nPUZBTFNFfQpsaWJyYXJ5KHBseXIpCmRkcGx5KGxhcG9wMTgsICJzbWVkaWEyciIsIHN1bW1hcmlzZSwgbWVhbj1tZWFuKHBuNHJyLCBuYS5ybT1UKSwgc2Q9c2QocG40cnIsIG5hLnJtPVQpKQpgYGAKCkVzIGltcG9ydGFudGUgbm90YXIgcXVlIGVuIGVzdGUgY2FzbyBubyBoZW1vcyBpbmRpY2FkbyBxdWUgaW50ZXJuYW1lbnRlIG5vIHNlIHRyYWJhamUgY29uIGxvcyB2YWxvcmVzIHBlcmRpZG9zICh1c2FuZG8gbGEgZXNwZWNpZmljYWNpw7NuIGBmaWx0ZXIoIWlzLm5hKHdhX3VzZXIpKWApLCBwb3IgbG8gcXVlIGxhIHRhYmxhIGFudGVyaW9yIHByZXNlbnRhIHVuYSBmaWxhIGRlIGxhcyBvYnNlcnZhY2lvbmVzIE5BIGRlIHVzdWFyaW8gZGUgbGEgcmVkIHNvY2lhbCwgZG9uZGUgc2UgY2FsY3VsYSBlbCBwcm9tZWRpbyB5IGxhIGRlc3ZpYWNpw7NuIGVzdMOhbmRhciBkZSBsYSB2YXJpYWJsZSBzYXRpc2ZhY2Npw7NuIGNvbiBsYSBkZW1vY3JhY2lhLgpGaW5hbG1lbnRlLCB1bmEgb3BjacOzbiBxdWUgcGVybWl0ZSBtb3N0cmFyIG11Y2hvcyBlc3RhZMOtc3RpY29zIHBvciBjYWRhIGdydXBvIGVzIGBkZXNjcmliZUJ5YCBkZSBsYSBsaWJyZXLDrWEgYHBzeWNoYC4KRWwgY8OzZGlnbyBwYXJhIFR3aXR0ZXIgZXM6CgpgYGB7ciBtZWRpYXBvcnJlZGVzMywgbWVzc2FnZT1GQUxTRSwgd2FybmluZz1GQUxTRX0KbGlicmFyeShwc3ljaCkKZGVzY3JpYmVCeShsYXBvcDE4JHBuNHJyLCBncm91cD1sYXBvcDE4JHNtZWRpYTVyKQpgYGAKClNpbiBlbWJhcmdvLCBsbyBxdWUgbm9zIGludGVyZXNhIGVzIGNhbGN1bGFyIGxvcyBpbnRlcnZhbG9zIGRlIGNvbmZpYW56YSBwYXJhIGNhZGEgZ3J1cG8uCkVuIGVsIGdyw6FmaWNvIDMuOSBkZWwgcmVwb3J0ZSBzZSBwcmVzZW50YSBsYSBtZWRpYSBkZSBzYXRpc2ZhY2Npw7NuIGNvbiBsYSBkZW1vY3JhY2lhLCBtb3N0cmFkbyBjb21vIHVuIHB1bnRvLCB5IGxvcyBpbnRlcnZhbG9zIGRlIGNvbmZpYW56YSBkZSBjYWRhIGdydXBvLCBtb3N0cmFkb3MgY29tbyB1biDDoXJlYSBncmlzIGNvbiBsw61taXRlcyBpbmZlcmlvciB5IHN1cGVyaW9yLgpTZSBwdWVkZSB1c2FyIGxhIGxpYnJlcsOtYSBgUm1pc2NgIHkgZWwgY29tYW5kbyBgZ3JvdXAuQ0lgIHBhcmEgY2FsY3VsYXIgbG9zIGludGVydmFsb3MgZGUgY29uZmlhbnphIGRlIGxhIHZhcmlhYmxlIHNhdGlzZmFjY2nDs24gY29uIGxhIGRlbW9jcmFjaWEgcG9yIGdydXBvcyBkZSBjb25zdW1vIGRlIGluZm9ybWFjacOzbiBlbiBGYWNlYm9vay4KCmBgYHtyIGNpcG9yZ3J1cG8sIG1lc3NhZ2U9RkFMU0UsIHdhcm5pbmc9RkFMU0V9CmxpYnJhcnkoUm1pc2MpCmdyb3VwLkNJKHBuNHJyfnNtZWRpYTJyLCBsYXBvcDE4KQpgYGAKCkNvbiBlc3RvcyBkYXRvcywgcG9yIGVqZW1wbG8sIGxhIG1lZGlhIGRlIHNhdGlzZmFjY2nDs24gY29uIGxhIGRlbW9jcmFjaWEgZW50cmUgZWwgZ3J1cG8gZGUgYWx0byB1c28gZGUgaW5mb3JtYWNpw7NuIGVuIEZhY2Vib29rIGVzIDM3LjYlLgpFbCBsw61taXRlIGluZmVyaW9yIGRlbCBpbnRlcnZhbG8gZGUgY29uZmlhbnphIGVzIDM2LjclIHkgZWwgbMOtbWl0ZSBzdXBlcmlvciBlcyAzOC40JS4KQ29uIGVzdG9zIGRhdG9zIHNlIHBvZHLDrWEgcmVwbGljYXIgdW4gZ3LDoWZpY28gZGUgYmFycmFzIHNpbWlsYXIgYWwgMy45LgoKIyMgSW50ZXJ2YWxvcyBkZSBjb25maWFuemEgZGUgc2F0aXNmYWNjacOzbiBjb24gbGEgZGVtb2NyYWNpYQoKTGEgZm9ybWEgbcOhcyBmw6FjaWwgZGUgZ3JhZmljYXIgbG9zIGludGVydmFsb3MgZGUgY29uZmlhbnphIHBvciBncnVwb3MgZXMgdXNhbmRvIGVsIGNvbWFuZG8gYHBsb3RtZWFuc2AuCgpgYGB7ciBncmFmeGdydXAsIG1lc3NhZ2U9RkFMU0UsIHdhcm5pbmc9RkFMU0V9CmxpYnJhcnkoZ3Bsb3RzKQpwbG90bWVhbnMobGFwb3AxOCRwbjRycn5sYXBvcDE4JHNtZWRpYTVyLAogICAgICAgICAgeGxhYj0iVGlwbyBkZSB1c3VhcmlvIGRlIFR3aXR0ZXIiLAogICAgICAgICAgeWxhYj0iU2F0aXNmYWNjacOzbiBjb24gbGEgZGVtb2NyYWNpYSIsCiAgICAgICAgICB5bGltPWMoMCwgNTApLAogICAgICAgICAgbWVhbi5sYWJlbHM9VCwgZGlnaXRzPTEsCiAgICAgICAgICBjb25uZWN0PUYKICAgICAgICAgKQpgYGAKCkVzdGEgb3BjacOzbiBtdWVzdHJhIGxvcyBpbnRlcnZhbG9zIGRlIGNvbmZpYW56YSBwZXJvIHNlIGRpZmljdWx0YSBzaSBzZSBxdWllcmUgZ3JhZmljYXIgbGFzIGJhcnJhcy4KTGEgbGlicmVyw61hIGBnZ3Bsb3RgIG5vcyBicmluZGEgbcOhcyBvcGNpb25lcyB5IG5vcyBwZXJtaXRlIGdyYWZpY2FyIGRlIG1hbmVyYSBzaW1pbGFyIGFsIGdyw6FmaWNvIDMuOSBkZWwgcmVwb3J0ZSwgZW4gYmFycmFzLCBwcmVzZW50YXIgbG9zIGludGVydmFsb3MgZGUgY29uZmlhbnphIHkgYWdyZWdhciBjb2xvci4KUGFyYSBlc3RvLCBwcmltZXJvIHNlIGd1YXJkYSB1biBkYXRhZnJhbWUgInR3LnVzbyIgY29uIGxvcyBkYXRvcyBkZSBsYSBtZWRpYSB5IGxvcyBsw61taXRlcyBzdXBlcmlvciBlIGluZmVyaW9yIGRlIGNhZGEgZ3J1cG8sIHVzYW5kbyBlbCBjb21hbmRvIGBncm91cC5DSWAuClNvbiBsb3MgZGF0b3MgZGUgZXN0ZSBkYXRhZnJhbWUgbG9zIHF1ZSBzZSB1c2FuIGNvbiBgZ2dwbG90YCB5IHNlIGNyZWEgdW4gZ3LDoWZpY28gcXVlIHNlIGd1YXJkYSBlbiB1biBvYmpldG8gImdyYWYxIi4KQ29uIGVzdGEgbGlicmVyw61hIHNlIGFncmVnYSBsYSBjYXBhIGBnZW9tX2JhcigpYCBwYXJhIGRlZmluaXIgcXVlIHNlIHF1aWVyZSB1biBncsOhZmljbyBkZSBiYXJyYXMgZGUgbGFzIHZhcmlhYmxlcyBlc3BlY2lmaWNhZGFzIGVuIGBhZXNgLgpMdWVnbywgc2UgYWdyZWdhIGxhIGNhcGEgYGdlb21fZXJyb3JiYXIoKWAgcGFyYSBhZ3JlZ2FyIGxhcyBiYXJyYXMgZGUgZXJyb3IgeSBsdWVnbyBsb3MgdmFsb3JlcyBkZSBsYSBtZWRpYSBjb24gYGdlb21fdGV4dCgpYC4KRmluYWxtZW50ZSwgc2UgZXRpcXVldGEgZWwgZWplIFggeSBZIGNvbiBgeGxhYmAgeSBgeWxhYmAgeSBzZSBkZWZpbmUgbG9zIGzDrW1pdGVzIGRlbCBlamUgWSBjb24gYHlsaW1gLgoKYGBge3IgZ3JhZnhncnVwMiwgbWVzc2FnZT1GQUxTRSwgd2FybmluZz1GQUxTRX0KdHcudXNvIDwtIGdyb3VwLkNJKHBuNHJyfnNtZWRpYTVyLCBsYXBvcDE4KQpsaWJyYXJ5KGdncGxvdDIpCmdyYWYyIDwtIGdncGxvdCh0dy51c28sIGFlcyh4PXNtZWRpYTVyLCB5PXBuNHJyLm1lYW4pKSsKICBnZW9tX2Jhcih3aWR0aD0wLjUsIGZpbGw9ImRhcmtjeWFuIiwgY29sb3VyPSJibGFjayIsIHN0YXQ9ImlkZW50aXR5IikrCiAgZ2VvbV9lcnJvcmJhcihhZXMoeW1pbj1wbjRyci5sb3dlciwgeW1heD1wbjRyci51cHBlciksIHdpZHRoPTAuMikrCiAgZ2VvbV90ZXh0KGFlcyhsYWJlbD1wYXN0ZShyb3VuZChwbjRyci5tZWFuLCAxKSwgIiUiKSksIHZqdXN0PS00LjIsIHNpemU9NCkrCiAgeGxhYigiVGlwbyBkZSB1c3VhcmlvIGRlIFR3aXR0ZXIiKSArIHlsYWIoIlNhdGlzZmFjY2nDs24gY29uIGxhIGRlbW9jcmFjaWEgKCUpIikrCiAgeWxpbSgwLCA1MCkKZ3JhZjIKYGBgCgpTZWfDum4gZXN0b3MgcmVzdWx0YWRvcywgbGEgc2F0aXNmYWNjacOzbiBjb24gbGEgZGVtb2NyYWNpYSBlcyBtw6FzIGFsdGEgZW4gYXF1ZWxsb3MgcXVlIG5vIHNvbiB1c3VhcmlvcyBkZSBUd2l0dGVyLCBlbiBjb21wYXJhY2nDs24gY29uIGxvcyB1c3VhcmlvcywgYXVucXVlIGxhcyBkaWZlcmVuY2lhcyBubyBzb24gZXN0YWTDrXN0aWNhbWVudGUgc2lnbmlmaWNhdGl2YXMgZGUgdW5hIGNvbXBhcmFjacOzbiB2aXN1YWwgZW50cmUgbG9zIGludGVydmFsb3MgZGUgY29uZmlhbnphLgoKIyMgU2F0aXNmYWNjacOzbiBjb24gbGEgZGVtb2NyYWNpYSBwb3IgdGlwbyBkZSB1c3VhcmlvIGRlIHJlZGVzIHNvY2lhbGVzCgpIYXN0YSBlbCBtb21lbnRvIHNlIGhhIGNyZWFkbyBpbnRlcnZhbG9zIGRlIGNvbmZpYW56YSBkZSBzYXRpc2ZhY2Npw7NuIGNvbiBsYSBkZW1vY3JhY2lhIHBvciB0aXBvIGRlIHVzdWFyaW9zIGRlIFR3aXR0ZXIuCkVsIHJlcG9ydGUgYWdyZWdhIGEgbG9zIHVzdWFyaW9zIGRlIGxhcyB0cmVzIHJlZGVzIHNvY2lhbGVzIHBhcmEgdWJpY2FyIHRyZXMgdGlwb3MgZGUgdXN1YXJpb3M6IHVzdWFyaW9zIGRlIGFsdG8gdXNvLCBkZSBiYWpvIHVzbyB5IG5vIHVzdWFyaW9zIGRlIGN1YWxxdWllciByZWQgc29jaWFsLgpMYSBmb3JtYSBkZSBjb2RpZmljYWNpw7NuIGRlIGVzdGUgdGlwbyBkZSB1c3VhcmlvcyBkZSB0cmVzIHJlZGVzIHNvY2lhbGVzIHNlIGJhc2EgZW4gdmFyaWFzIGNvbmRpY2lvbmVzLgpDb21vIGRpY2UgZWwgcmVwb3J0ZTogIlVzYW1vcyBsYSBtaXNtYSBjb2RpZmljYWNpw7NuIHF1ZSBlbiBsYSBhbnRlcmlvciBzZWNjacOzbiwgcGFyYSBkaXN0aW5ndWlyIGVudHJlIHF1aWVuZXMgYWNjZWRlbiBjb24gZnJlY3VlbmNpYSBlbiByZWRlcyBzb2NpYWxlcyAoYXF1ZWxsb3MgY29uIGN1ZW50YXMgYSBsYXMgcXVlIGFjY2VkZW4gYWxndW5hcyB2ZWNlcyBhIGxhIHNlbWFuYSBvIGEgZGlhcmlvKSB5IGFxdWVsbG9zIHF1ZSBubyBhY2NlZGVuIGEgbGFzIHJlZGVzIHNvY2lhbGVzIG11eSBmcmVjdWVudGVtZW50ZSAoYXF1ZWxsb3MgY29uIGN1ZW50YXMgYSBsYXMgcXVlIGFjY2VkZW4gYWxndW5hcyB2ZWNlcyBhbCBtZXMgbyBhbGd1bmFzIHZlY2VzIGFsIGHDsW8pLiBUYW1iacOpbiBpbmNsdWltb3MgYSBxdWllbmVzIG5vIHNvbiB1c3VhcmlvczogcXVpZW5lcyBubyB0aWVuZW4gbmluZ3VuYSBjdWVudGEgZW4gcmVkZXMgc29jaWFsZXMgKHF1aWVuZXMgaW5kaWNhbiBxdWUgbm8gdGllbmVuIHVuYSBjdWVudGEgZW4gRmFjZWJvb2ssIFR3aXR0ZXIgbyBXaGF0c2FwcCkgeSBxdWllbmVzIHRpZW5lbiB1bmEgY3VlbnRhLCBwZXJvIG51bmNhIGxhIHVzYW4iIChwLjgxKS4KRW4gcHJpbWVyIGx1Z2FyIGlkZW50aWZpY2Ftb3MgYSBxdWllbmVzIHVzYW4gY2FkYSByZWQgc29jaWFsIGFsZ3VuYXMgdmVjZXMgYSBsYSBzZW1hbmEgbyBhIGRpYXJpbyBjb21vIDEgeSBzaSB1c2FuIGNhZGEgcmVkIHNvY2lhbCBhbGd1bmFzIHZlY2VzIGFsIG1lcyBvIGFsZ3VuYXMgdmVjZXMgYWwgYcOxbywgY29tbyAwLgpQYXJhIGVzdG8gdXNhbW9zIGVsIGNvbWFuZG8gYGlmZWxzZWAuCkx1ZWdvLCBzdW1hbW9zIGxvcyB2YWxvcmVzIGRlIGNhZGEgcmVkIHNvY2lhbCBlbiB1bmEgc29sYSB2YXJpYWJsZSwgY29uIHZhbG9yZXMgZW50cmUgMCB5IDMuClNlIHVzYSBlbCBjb21hbmRvIGByb3dTdW1zYCBxdWUgcGVybWl0ZSBsYSBzdW1hIGhvcml6b250YWwgZGUgdmFyaWFibGVzIGRlZmluaWRhcywgZW4gZXN0ZSBjYXNvIGxhcyBxdWUgZXN0w6FuIGVuIGxhIHBvc2ljacOzbiBgWywgODk6OTFdYC4KRW4gZXN0ZSBjb21hbmRvLCB1c2Ftb3MgbGEgZXNwZWNpZmljYWNpw7NuIGBuYS5ybT1UYCBwYXJhIHF1ZSBsYSBzdW1hIG5vIHRvbWUgZW4gY3VlbnRhIGEgbG9zIHZhbG9yZXMgcGVyZGlkb3MuCgpgYGB7ciB1c3VhcmlvcmVkZXN9CmxhcG9wMTgkc20yIDwtIGlmZWxzZShsYXBvcDE4JHNtZWRpYTI9PTEgfCBsYXBvcDE4JHNtZWRpYTI9PTIsIDEsIDApCmxhcG9wMTgkc201IDwtIGlmZWxzZShsYXBvcDE4JHNtZWRpYTU9PTEgfCBsYXBvcDE4JHNtZWRpYTU9PTIsIDEsIDApCmxhcG9wMTgkc204IDwtIGlmZWxzZShsYXBvcDE4JHNtZWRpYTg9PTEgfCBsYXBvcDE4JHNtZWRpYTg9PTIsIDEsIDApCmxhcG9wMTgkYW55aGkgPSByb3dTdW1zKGxhcG9wMThbLDg5OjkxXSwgbmEucm09VCkKdGFibGUobGFwb3AxOCRhbnloaSkKYGBgCgpQYXJ0aWVuZG8gZGUgZXN0YSB2YXJpYWJsZSwgc2UgY3JlYSB1bmEgdmFyaWFibGUgcXVlIGFncmVnYSBsYXMgdHJlcyByZWRlcyBzb2NpYWxlcywgbGxhbWFkYSAiaGlfbG9fbm9uIi4KUHJpbWVybywgc2UgY3JlYSBlc3RhIHZhcmlhYmxlIGNvbW8gdW4gdmVjdG9yIGRlIE5Bcy4KTHVlZ28gc2UgbGUgaW1wdXRhIHZhbG9yZXMgZGUgMSwgMiwgMyBvIE5BLCBkZXBlbmRpZW5kbyBkZSBsb3MgdmFsb3JlcyBkZSAiYW55aGkgbyBkZSBsb3MgdmFsb3JlcyBkZSBsYXMgdmFyaWFibGVzIGRlIHJlZGVzIHNvY2lhbGVzLiBMdWVnbyBzZSBjcmVhIHVuYSBudWV2YSB2YXJpYWJsZSBkZSB0aXBvIGZhY3RvciwgY29uIGlkw6ludGljb3MgdmFsb3JlcyBxdWUgImhpX2xvX25vbiIgeSBzZSBldGlxdWV0YS4gTGEgZGVmaW5pY2nDs24gZGUgbGEgY29uZGljaW9uYWxpZGFkIHNlIHRyYWJhamEgbWVkaWFudGUgbG9zIGNvcmNoZXRlcyBgWy4uLl1gLiBEZSBlc3RhIG1hbmVyYSwgc2UgZGVmaW5lIGxhcyBjb25kaWNpb25lcyBkZSBsYSBzaWd1aWVudGUgbWFuZXJhOgoKLSAgIExhIHZhcmlhYmxlICJoaV9sb19ub24gZXMgaWd1YWwgYSAxIHNpIGxhIHZhcmlhYmxlIGFueWhpIGVzIG1heW9yIG8gaWd1YWwgYSAxICh1c28gZGlhcmlvIG8gYWxndW5hcyB2ZWNlcyBhIGxhIHNlbWFuYSkgPSBgbGFwb3AxOCRoaV9sb19ub25bbGFwb3AxOCRhbnloaT49MV0gPC0gMWAKCi0gICBMYSB2YXJpYWJsZSAiaGlfbG9fbm9uIGVzIGlndWFsIGEgMiBzaSBsYSB2YXJpYWJsZSBhbnloaSBlcyBpZ3VhbCBhIDAgKHVzbyBhbGd1bmFzIHZlY2VzIGFsIGHDsW8gbyBudW5jYSkgPSBgbGFwb3AxOCRoaV9sb19ub25bbGFwb3AxOCRhbnloaT09MF0gPC0gMmAKCi0gICBMYSB2YXJpYWJsZSAiaGlfbG9fbm9uIGVzIGlndWFsIGEgMyBzaSBsYXMgdmFyaWFibGVzIGRlIHRlbmVuY2lhIGRlIGN1ZW50YXMgc29uIGlndWFsIGEgMiAoTm8pID0gYGxhcG9wMTgkaGlfbG9fbm9uW2xhcG9wMTgkc21lZGlhMT09MiAmIGxhcG9wMTgkc21lZGlhND09MiAmIGxhcG9wMTgkc21lZGlhNz09Ml0gPC0gM2AKCkxhcyBzaWd1aWVudGUgcmVnbGFzIGRlIGNvZGlmaWNhY2nDs24gc2lndWVuIGxhIG1pc21hIGzDs2dpY2EgZGUgY29tYmluYWNpw7NuIGRlIG90cmFzIHZhcmlhYmxlcyBwYXJhIGltcHV0YXIgZWwgdmFsb3IgMyBvIE5BLgoKYGBge3IgaGlsb25vbn0KbGFwb3AxOCRoaV9sb19ub24gPC0gTkEgI3NlIGNyZWEgdW4gdmVjdG9yIGNvbiBOQXMjCmxhcG9wMTgkaGlfbG9fbm9uW2xhcG9wMTgkYW55aGk+PTFdIDwtIDEgI1NlIGNvZGlmaWNhIDEgYSBsb3MgcXVlIHVzYW4gZGlhcmlhbWVudGUgbyBhbGd1bmFzIHZlY2VzIGEgbGEgc2VtYW5hIGFsZ3VuYSByZWQgc29jaWFsIwpsYXBvcDE4JGhpX2xvX25vbltsYXBvcDE4JGFueWhpPT0wXSA8LSAyICNTZSBjb2RpZmljYSBjb21vIDIgYSBsb3MgcXVlIHVzYW4gYWxndW5hcyB2ZWNlcyBhbCBtZXMgeSBhbCBhw7FvIGFsZ3VuYSByZWQgc29jaWFsIwpsYXBvcDE4JGhpX2xvX25vbltsYXBvcDE4JHNtZWRpYTE9PTIgJiBsYXBvcDE4JHNtZWRpYTQ9PTIgJiBsYXBvcDE4JHNtZWRpYTc9PTJdIDwtIDMgI1NlIGNvZGlmaWNhIGNvbW8gMyBhIGxvcyBxdWUgbm8gdGllbmUgcmVkZXMgc29jaWFsZXMjCmxhcG9wMTgkaGlfbG9fbm9uW2xhcG9wMTgkc21lZGlhMj09NSAmIGxhcG9wMTgkc21lZGlhNT09NSAmIGxhcG9wMTgkc21lZGlhOD09NV0gPC0gMyAjU2UgY29kaWZpY2EgY29tbyAzIGEgbG9zIHF1ZSBudW5jYSB1c2FuIG5pbmd1bmEgcmVkIHNvY2lhbCMKbGFwb3AxOCRoaV9sb19ub25bbGFwb3AxOCRwYWlzPT0zICYgKGxhcG9wMTgkc21lZGlhMj09NSB8IGxhcG9wMTgkc21lZGlhNT09NSB8IGxhcG9wMTgkc21lZGlhOD09NSldIDwtIDMgI1NlIGFwbGljYSB1biBjw7NkaWdvIHBhcnRpY3VsYXIgYSBwYWlzIDMjCmxhcG9wMTgkaGlfbG9fbm9uW2xhcG9wMTgkcGFpcz09MyAmIChsYXBvcDE4JHNtZWRpYTE9PTIgfCBsYXBvcDE4JHNtZWRpYTQ9PTIgfCBsYXBvcDE4JHNtZWRpYTc9PTIpXSA8LSAzICNTZSBhcGxpY2EgdW4gY8OzZGlnbyBwYXJ0aWN1bGFyIGEgcGFpcyAzIwpsYXBvcDE4JGhpX2xvX25vbltsYXBvcDE4JGhpX2xvX25vbiAhPSAxICYgKGxhcG9wMTgkc21lZGlhMj09TkEgfCBsYXBvcDE4JHNtZWRpYTU9PU5BIHwgbGFwb3AxOCRzbWVkaWE4PT1OQSldIDwtIE5BICNTZSBjb2RpZmljYW4gbG9zIHZhbG9yZXMgcGVyZGlkb3MgY29tbyBwZXJkaWRvcyMKbGFwb3AxOCRoaV9sb19ub25bbGFwb3AxOCRoaV9sb19ub24gIT0gMSAmIChsYXBvcDE4JHNtZWRpYTE9PU5BIHwgbGFwb3AxOCRzbWVkaWE0PT1OQSB8IGxhcG9wMTgkc21lZGlhNz09TkEpXSA8LSBOQQpsYXBvcDE4JGhpX2xvX25vbltsYXBvcDE4JHNtZWRpYTE9PU5BICYgbGFwb3AxOCRzbWVkaWE0PT1OQSAmIGxhcG9wMTgkc21lZGlhNz09TkFdIDwtIE5BCmxhcG9wMTgkaGlfbG9fbm9uW2xhcG9wMTgkaGlfbG9fbm9uICE9MyAmIGxhcG9wMTgkc21lZGlhMj09TkEgJiBsYXBvcDE4JHNtZWRpYTU9PU5BICYgbGFwb3AxOCRzbWVkaWE4PT1OQV0gPC0gTkEKbGFwb3AxOCRoaWxvbiA8LSBhcy5mYWN0b3IobGFwb3AxOCRoaV9sb19ub24pCmxldmVscyhsYXBvcDE4JGhpbG9uKSA8LSBjKCJBbHRvIHVzbyIsICJCYWpvIHVzbyIsICJObyB1c3VhcmlvIikKcHJvcC50YWJsZSh0YWJsZShsYXBvcDE4JGhpbG9uKSkqMTAwCmBgYAoKU2Vnw7puIGVzdG9zIGRhdG9zLCBlbCA2NC45JSBkZSBlbnRyZXZpc3RhZG9zIHJlcG9ydGFuIHVuIGFsdG8gdXNvIGRlIHJlZGVzIHNvY2lhbGVzLCBtaWVudHJhcyBxdWUsIGVuIGVsIG90cm8gZXh0cmVtbywgc2UgdGllbmUgMzEuNiUgcXVlIHNlcsOtYW4gbm8gdXN1YXJpb3MgZGUgbmluZ3VuYSByZWQgc29jaWFsLgpFc3RvcyBkYXRvcyBkaWZpZXJlbiB1biBwb2NvIGRlIGxvcyByZXBvcnRhZG9zIGVuIGVsIEFww6luZGljZSBhbCByZXBvcnRlLCBkaXNwb25pYmxlIFthcXXDrV0oaHR0cHM6Ly93d3cudmFuZGVyYmlsdC5lZHUvbGFwb3AvYWIyMDE4L0FwcGVuZGl4X01hdGVyaWFsX2Zvcl8yMDE4LTE5X0FtZXJpY2FzQmFyb21ldGVyX1JlcG9ydC1Db21wYXJhdGl2ZV9DaGFwdGVyc18xMC4xMy4xOS5wZGYpLCBkb25kZSBzZSByZXBvcnRlIDY1LjM0JSBkZSBhbHRvIHVzbyB5IDMxLjYwJSBkZSBubyB1c3Vhcmlvcy4KRXN0YXMgZGlmZXJlbmNpYXMgcHVlZGVuIHNlciBkZWJpZGFzIGEgZGlmZXJlbmNpYXMgZW4gbGEgaW50ZXJwcmV0YWNpw7NuIGRlIGxhcyByZWdsYXMgZGUgY29kaWZpY2FjacOzbiBkZXNkZSBTdGF0YSBhIFIuCgpEZSBsYSBtaXNtYSBmb3JtYSBxdWUgc2UgcHJvZHVqbyBlbCBncsOhZmljbyBkZSBtZWRpYSBkZSBzYXRpc2ZhY2Npw7NuIGNvbiBsYSBkZW1vY3JhY2lhIHBvciB0aXBvcyBkZSB1c3VhcmlvcyBkZSBUd2l0dGVyIHVzYW5kbyBgZ2dwbG90YCwgYWhvcmEgc2UgaGFyw6EgbG8gbWlzbW8gcGVybyBwYXJhIGxvcyB1c3VhcmlvcyBkZSBsYXMgdHJlcyByZWRlcyBzb2NpYWxlcywgdmFyaWFibGUgImhpbG9uIi4KCmBgYHtyIGdyYWYzLjl9CmxpYnJhcnkoUm1pc2MpCnNhdGlzLnVzbyA8LSBncm91cC5DSShwbjRycn5oaWxvbiwgbGFwb3AxOCkKbGlicmFyeShnZ3Bsb3QyKQpncmFmMy45IDwtIGdncGxvdChzYXRpcy51c28sIGFlcyh4PWhpbG9uLCB5PXBuNHJyLm1lYW4pKSsKICBnZW9tX2Jhcih3aWR0aD0wLjUsIGZpbGw9ImRhcmtjeWFuIiwgY29sb3VyPSJibGFjayIsIHN0YXQ9ImlkZW50aXR5IikrCiAgZ2VvbV9lcnJvcmJhcihhZXMoeW1pbj1wbjRyci5sb3dlciwgeW1heD1wbjRyci51cHBlciksIHdpZHRoPTAuMikrCiAgZ2VvbV90ZXh0KGFlcyhsYWJlbD1wYXN0ZShyb3VuZChwbjRyci5tZWFuLCAxKSwgIiUiKSksIHZqdXN0PS0yLjUsIHNpemU9NCkrCiAgeGxhYigiVGlwbyBkZSB1c3VhcmlvIGRlIHJlZGVzIHNvY2lhbGVzIikgKyB5bGFiKCJTYXRpc2ZhY2Npw7NuIGNvbiBsYSBkZW1vY3JhY2lhICglKSIpKwogIHlsaW0oMCwgNTApCmdyYWYzLjkKYGBgCgpFc3RlIGdyw6FmaWNvIHNlcsOtYSB1bmEgcmVwcm9kdWNjacOzbiBkZWwgcXVlIHNlIHByZXNlbnRhIGVuIGVsIGluZm9ybWUgKEdyw6FmaWNvIDMuOSBlbiBsYSBww6FnaW5hIDYyKSwgY29uIHVuYSBtw61uaW1hcyBkaWZlcmVuY2lhcyBwb3IgY29kaWZpY2FjacOzbiBkZSBsb3MgZGF0b3MgcmVzdWx0YW50ZXMuCgojIFJlc3VtZW4KCkVuIGVzdGUgZG9jdW1lbnRvIHNlIGhhIHRyYWJhamFkbyBjb24gdW5hIHZhcmlhYmxlIHJlY29kaWZpY2FkYSBkdW1teSAoc2F0aXNmYWNjacOzbiBjb24gbGEgZGVtb2NyYWNpYSksIGxhIHF1ZSBwdWVkZSBzZXIgdHJhYmFqYWRhIGNvbW8gdmFyaWFibGUgbnVtw6lyaWNhIHBhcmEgZWwgY8OhbGN1bG8gZGUgaW50ZXJ2YWxvcyBkZSBjb25maWFuemEgZGUgcHJvcG9yY2lvbmVzLgpDb24gZXN0YSB2YXJpYWJsZSBzZSBoYSBjYWxjdWxhZG8gZWwgaW50ZXJ2YWxvIGRlIGNvbmZpYW56YSBkZSBsYSBtZWRpYSwgcXVlIHNlcsOtYSBlbCBkZSBsYSBwcm9wb3JjacOzbiBkZSBlbnRyZXZpc3RhZG9zIHF1ZSBlc3TDoW4gc2F0aXNmZWNob3MgY29uIGxhIGRlbW9jcmFjaWEuCkx1ZWdvLCBzZSBoYSBkZXNjcml0byBlc3RhIHZhcmlhYmxlcyBwb3IgZ3J1cG9zIGRlIHVuYSB2YXJpYWJsZSBkZSBmYWN0b3IgKGNvbnN1bW8gZGUgaW5mb3JtYWNpw7NuIHBvbMOtdGljYSkuClNlIGhhIHByZXNlbnRhZG8gY8OzbW8gY2FsY3VsYXIgbG9zIGludGVydmFsb3MgZGUgY29uZmlhbnphIGRlIGxhIHZhcmlhYmxlIG51bcOpcmljYSBwb3IgZ3J1cG9zIGRlIGxhIHZhcmlhYmxlIGRlIGZhY3Rvci4KRmluYWxtZW50ZSwgc2UgaGEgcHJlc2VudGFkbyBjw7NtbyBncmFmaWNhciBsb3MgaW50ZXJ2YWxvcyBkZSBjb25maWFuemEgcG9yIGdydXBvcy4KCiMgQ8OhbGN1bG9zIGluY2x1eWVuZG8gZWwgZWZlY3RvIGRlIGRpc2XDsW8KCiMjIFJlc3VsdGFkb3MgZGUgdG9sZXJhbmNpYSBhIGxvcyBnb2xwZXMgZWplY3V0aXZvcyBwb25kZXJhZG9zCgpDb21vIHNlIG1lbmNpb27DsywgbG9zIHJlc3VsdGFkb3Mgb2J0ZW5pZG9zIGFjZXJjYSBkZSBsYSB0b2xlcmFuY2lhIGRlIGxvcyBnb2xwZXMgZWplY3V0aXZvcywgZ3LDoWZpY28gMS43IGRlbCByZXBvcnRlIEVsIFB1bHNvIGRlIGxhIERlbW9jcmFjaWEgMjAyMSwgbm8gc29uIGlndWFsZXMgYSBsb3Mgb2J0ZW5pZG9zIGFxdcOtLgpFc3RvIGVzIGRlYmlkbyBhIHF1ZSBsb3MgY8OhbGN1bG9zIGRlIG3DoXMgYXJyaWJhIG5vIGluY2x1eWUgZWwgZWZlY3RvIGRlIGRpc2XDsW8uCgpQYXJhIHBvZGVyIHJlYWxpemFyIGxvcyBjw6FsY3Vsb3MgdG9tYW5kbyBlbiBjdWVudGEgZWwgZWZlY3RvIGRlIGRpc2XDsW8sIHNlIHB1ZWRlIHVzYXIgbGEgbGlicmVyw61hIGBzdXJ2ZXlgIHBhcmEgZGVmaW5pciBlbCBkaXNlw7FvIG11ZXN0cmFsLgpQcmltZXJvLCBzZSB0aWVuZSBxdWUgYWRlY3VhciBsYSBiYXNlIGRlIGRhdG9zLCBlbGltaW5hbmRvIGxvcyB2YWxvcmVzIHBlcmRpZG9zIGRlIGxhcyB2YXJpYWJsZXMgcXVlIGRlZmluZW4gZWwgZGlzZcOxbyBtdWVzdHJhbCAoY29tbyAid2VpZ2h0MTUwMCIpLgpVbiBwYXNvIGFkaWNpb25hbCBlcyB0cmFuc2Zvcm1hciBsYXMgdmFyaWFibGVzIGRlbCBkYXRhZnJhbWUuCkVzdG8gZXMgZGViaWRvIGEgcXVlIGN1YW5kbyBzZSBpbXBvcnRhbiwgZWwgc2lzdGVtYSBsZWUgbGFzIHZhcmlhYmxlcyBjb21vIHRpcG8gImhhdmVuX2xhYmVsbGVkIiwgZXMgZGVjaXIsIG1hbnRpZW5lIGxhcyBldGlxdWV0YXMgZGUgbGFzIHZhcmlhYmxlcywgY29uIGxvIHF1ZSBzZSBwb2Ryw61hIHByb2R1Y2lyIHVuIGxpYnJvIGRlIGPDs2RpZ29zLgpFc3RvIGVzIMO6dGlsIGVuIG90cmFzIG9jYXNpb25lcywgcGVybyBnZW5lcmEgcHJvYmxlbWFzIGNvbiBsYSBsaWJyZXLDrWEgYHN1cnZleWAuClBhcmEgZXN0byB0cmFuc2Zvcm1hbW9zIGxhcyB2YXJpYWJsZXMgYSBvdHJvIHRpcG8gY29uIGVsIGNvbWFuZG8gYHNhcHBseWAuCgpgYGB7ciBwcmVwYXJhY2lvbiBkZSBiYXNlLCBlY2hvPVRSVUUsIG1lc3NhZ2U9RkFMU0UsIHdhcm5pbmc9RkFMU0UsIHJlc3VsdHM9J2hpZGUnfQpsYXBvcDIxID0gc3Vic2V0KGxhcG9wMjEsICFpcy5uYSh3ZWlnaHQxNTAwKSkKc2FwcGx5KGxhcG9wMjEsIGhhdmVuOjp6YXBfbGFiZWxzKQpgYGAKCkNvbiBsYSBiYXNlIGRlIGRhdG9zIGFkZWN1YWRhLCBzZSBwdWVkZSBkZWZpbmlyIGVsIGRpc2XDsW8gbXVlc3RyYSB5IHNlIGd1YXJkYSBlbiB1biBvYmpldG8gImRpc2VubzIxIi4KCmBgYHtyIGRpc2VubzIxfQpsaWJyYXJ5KHN1cnZleSkKZGlzZW5vMjEgPSBzdnlkZXNpZ24oaWRzID0gfnVwbSwgc3RyYXRhID0gfnN0cmF0YSwgd2VpZ2h0cyA9IH53ZWlnaHQxNTAwLCBuZXN0PVRSVUUsIGRhdGE9bGFwb3AyMSkKYGBgCgpMYSBsaWJyZXLDrWEgYHN1cnZleWAgdGllbmUgY29tYW5kb3MgbmF0aXZvcyBwYXJhIGNhbGN1bGFyIGxhIG1lZGlhIGRlIGxhIHZhcmlhYmxlIHJlY29kaWZpY2FkYSBkZSB0b2xlcmFuY2lhIGEgbG9zIGdvbHBlcyBlamVjdXRpdm9zLgpFc3RlIGPDoWxjdWxvIGRlIGxhIG1lZGlhIG5vcyBicmluZGEgZWwgcG9yY2VudGFqZSBkZSBjaXVkYWRhbm9zIGVuIGxhIHJlZ2nDs24gcXVlIHNvbiB0b2xlcmFudGVzIGEgbG9zIGdvbHBlcyBlamVjdXRpdm9zLgoKYGBge3IgdG9sZXJhbmNpYSBwb25kZXJhZGF9CnN2eW1lYW4ofmpjMTVhciwgZGlzZW5vMjEsIG5hLnJtPVQpCmBgYAoKUGFyYSBjYWxjdWxhciBlbCBpbnRlcnZhbG8gZGUgY29uZmlhbnphIGRlIGVzdGEgbWVkaWRhIHNlIHB1ZWRlIGFuaWRhciBlbCBjb21hbmRvIGBzdnltZWFuYCBkZW50cm8gZGUgb3RybyBjb21hbmRvIGBjb25maW50YCBxdWUgbm9zIGJyaW5kYSBlbCBsw61taXRlIGluZmVyaW9yIHkgc3VwZXJpb3IgZGVsIGludGVydmFsbyBkZSBjb25maWFuemEuCgpgYGB7ciBpYyB0b2xlcmFuY2lhIHBvbmRlcmFkYX0KY29uZmludChzdnltZWFuKH5qYzE1YXIsIGRpc2VubzIxLCBuYS5ybT1UKSkKYGBgCgpQYXJhIHBvZGVyIHJlcGxpY2FyIGVsIGdyw6FmaWNvIDEuNyByZXF1ZXJpbW9zIGVsIHZhbG9yIGRlbCBwb3JjZW50YWplIGRlIGNpdWRhZGFub3MgcXVlIHRvbGVyYW4gbG9zIGdvbHBlcyBlamVjdXRpdm9zIHBvciBww6FpcywgYXPDrSBjb21vIGVsIGludGVydmFsbyBkZSBjb25maWFuemEgZGUgY2FkYSB1bm8uClBhcmEgZXN0ZSBjw6FsY3VsbywgcG9kZW1vcyB1c2FyIGVsIGNvbWFuZG8gYHN2eWJ5YC4KRXN0ZSBjb21hbmRvIHJlcXVpZXJlIGRlZmluaXIgbGEgdmFyaWFibGUgYSBzZXIgY2FsY3VsYWRhIChgfmpjMTVhcmApLCBsYSB2YXJpYWJsZSBxdWUgZGVmaW5lIGxvcyBncnVwb3MgKGB+cGFpc2VzYCksIGVsIG9iamV0byBxdWUgZ3VhcmRhIGVsIGRpc2XDsW8gbXVlc3RyYWwgKGBkaXNlbm8yMWApLCBlbCBlc3RhZMOtc3RpY28gcXVlIHNlIHF1aWVyZSBjYWxjdWxhciAoYHN2eW1lYW4sIG5hLnJtPVRgKSB5IGRlZmluaXIgZWwgaW50ZXJ2YWxvIGRlIGNvbmZpYW56YSAoYHZhcnR5cGUgPSAiY2kiYCkuCkVzdG9zIGPDoWxjdWxvcyBzZSBndWFyZGFuIGVuIHVuIG9iamV0byAiZ29scGVwb25kIi4KCmBgYHtyIHRvbGVyYW5jaWEgcG9yIHBhaXMgcG9uZGVyYWRhfQpnb2xwZXBvbmQgPSBzdnlieSh+amMxNWFyLCB+cGFpc2VzLCBkaXNlbm8yMSwgc3Z5bWVhbiwgbmEucm09VCwgdmFydHlwZSA9ICJjaSIpCmdvbHBlcG9uZCA9IGdvbHBlcG9uZFstYyg2LDIwKSxdCmBgYAoKRGUgbGEgbWlzbWEgbWFuZXJhIHF1ZSBjb24gZWwgZ3LDoWZpY28gY29uIGxvcyByZXN1bHRhZG9zIG5vIHBvZGVyYWRvcywgdXNhbW9zIGxhIGxpYnJlcsOtYSBgZ2dwbG90YCBwYXJhIHJlcGxpY2FyIGVsIGdyw6FmaWNvIDEuNy4KU2UgZGViZSB0b21hciBlbiBjdWVudGEgcXVlIGVsIGNvbWFuZG8gYHN2eWJhcmAgZ2VuZXJhIGNvbHVtbmFzIGNvbiBub21icmUgZGlmZXJlbnRlcyBhIGxvcyBxdWUgc2UgZ2VuZXJhbiBjb24gZWwgY29tYW5kbyBgZ3JvdXAuQ0lgIHVzYWRvIG3DoXMgYXJyaWJhLgoKYGBge3IgZ3JhZmljbyB0b2xlcmFuY2lhIHBvbmRlcmFkYX0KZ3JhZjMgPC0gZ2dwbG90KGdvbHBlcG9uZCwgYWVzKHg9cmVvcmRlcihwYWlzZXMsIC1qYzE1YXIpLCB5PWpjMTVhcikpKwogIGdlb21fYmFyKHdpZHRoPTAuNSwgZmlsbD0iZGFya3NsYXRlZ3JheTMiLCBjb2xvdXI9IiM2OWIzYTIiLCBzdGF0PSJpZGVudGl0eSIpKwogIGdlb21fZXJyb3JiYXIoYWVzKHltaW49Y2lfbCwgeW1heD1jaV91KSwgd2lkdGg9MC4yLCBjb2xvcj0iZGFya2N5YW4iLAogICAgICAgICAgICAgICAgY2V4PTAuNCwgbGluZXR5cGU9MykrCiAgZ2VvbV90ZXh0KGFlcyhsYWJlbD1wYXN0ZShyb3VuZChqYzE1YXIsIDApLCAiJSIpKSwgdmp1c3Q9LTQuNCwgc2l6ZT0yLjUpKwogIHhsYWIoIlBhw61zIikgKyB5bGFiKCJUb2xlcmFuY2lhIGEgZ29scGVzIGVqZWN1dGl2b3MgKCUpIikrCiAgeWxpbSgwLCA2MCkKZ3JhZjMKCgpgYGAKCkRlIGVzdGEgbWFuZXJhIHNlIGhhIHJlcGxpY2FkbyBleGFjdGFtZW50ZSBsb3MgcmVzdWx0YWRvcyByZXBvcnRhZG9zIGVuIEVsIFB1bHNvIGRlIGxhIERlbW9jcmFjaWEgMjAyMS4KCiMjIFJlc3VsdGFkb3MgZGUgc2F0aXNmYWNjacOzbiBjb24gbGEgZGVtb2NyYWNpYSBwb25kZXJhZG9zCgpEZSBsYSBtaXNtYSBtYW5lcmEgcXVlIGNvbiBsYSB0b2xlcmFuY2lhIGEgbG9zIGdvbHBlcyBlamVjdXRpdm9zLCBzZSB1c2EgbGEgbGlicmVyw61hIGBzdXJ2ZXlgIHkgZWwgY29tYW5kbyBgY29uZmludGBqdW50byBhbCBjb21hbmRvIG5hdGl2byBgc3Z5bWVhbmAuCgpgYGB7ciBkaXNlbm8xOH0KbGlicmFyeShzdXJ2ZXkpCmRpc2VubzE4PC1zdnlkZXNpZ24oaWRzID0gfnVwbSwgc3RyYXRhID0gfmVzdHJhdG9wcmksIHdlaWdodHMgPSB+d2VpZ2h0MTUwMCwgbmVzdD1UUlVFLCBkYXRhPWxhcG9wMTgpCmBgYAoKU2UgcHVlZGUgZGVzY3JpYmlyIGxhIHZhcmlhYmxlIGRlIHNhdGlzZmFjY2nDs24gY29uIGxhIGRlbW9jcmFjaWEgaW5jb3Jwb3JhbmRvIGVsIGZhY3RvciBkZSBkaXNlw7FvIHVzYW5kbyBlbCBjb21hbmRvIGBzdnltZWFuYC4KCmBgYHtyIHdlaWdodGVkcG40fQpzdnltZWFuKH5wbjRyciwgZGlzZW5vMTgsIG5hLnJtPVQpCmBgYAoKUGFyYSBjYWxjdWxhciBlbCBpbnRlcnZhbG8gZGUgY29uZmlhbnphLCBzZSB0aWVuZSBxdWUgYW5pZGFyIGVsIGPDs2RpZ28gYW50ZXJpb3IgZGVudHJvIGRlbCBjb21hbmRvIGBjb25maW50YC4KRXN0ZSBjb21hbmRvIGNhbGN1bGEgZWwgaW50ZXJ2YWxvIGRlIGNvbmZpYW56YSBhbCA5NSUgcG9yIGRlZmVjdG8uClNlIHBvZHLDrWEgY2FtYmlhciBlc3RlIHZhbG9yIHBvciBkZWZlY3RvIGEgOTklIGRlIGNvbmZpYW56YSBhZ3JlZ2FuZG8gbGEgZXNwZWNpZmljYWNpw7NuIGBjb25mID0gMC45OWAgYWwgY29tYW5kby4KCmBgYHtyIHdlaWdodGVkY2l9CmNvbmZpbnQoc3Z5bWVhbih+cG40cnIsIGRpc2VubzE4LCBuYS5ybT1UKSkKYGBgCgpUYW1iacOpbiBzZSBwdWVkZSBjYWxjdWxhciBsYSBtZWRpYSB5IGVsIGludGVydmFsbyBkZSBjb25maWFuemEgZGUgc2F0aXNmYWNjacOzbiBjb24gbGEgZGVtb2NyYWNpYSBpbmNvcnBvcmFuZG8gZWwgZWZlY3RvIGRlIGRpc2XDsW8gdXNhbmRvIGVsIGNvbWFuZG8gYHN2eWJ5YC4KRGVudHJvIGRlIGVzdGUgY29tYW5kbyBzZSBlc3BlY2lmaWNhIGxhIHZhcmlhYmxlIG51bcOpcmljYSBhIHNlciBkZXNjcml0YSAoYH5wbjRycmApLCBsYSB2YXJpYWJsZSBxdWUgZm9ybWEgbG9zIGdydXBvcyAoYH5zbWVkaWE1cmApLCBlbCBkaXNlw7FvIG11ZXN0cmFsIChgZGlzZW5vMThgKSwgbGEgZnVuY2nDs24gcXVlIHNlIHF1aWVyZSBjYWxjdWxhciAoYHN2eW1lYW5gKSwgcXVlIG5vIHRvbWUgZW4gY3VlbnRhIGxvcyB2YWxvcmVzIHBlcmRpZG9zIChgbmEucm09VGApIHkgcXVlIGluY2x1eWEgZWwgaW50ZXJ2YWxvIGRlIGNvbmZpYW56YSBkZSBjYWRhIGdydXBvIChgdmFydHlwZT0iY2kiYCkuCgpgYGB7ciB3ZWlnaHRlZGNpeGdydXBvc30KdHcudXNvLndlaWdodGVkIDwtIHN2eWJ5KH5wbjRyciwgfnNtZWRpYTVyLCBkaXNlbm8xOCwgc3Z5bWVhbiwgbmEucm09VCwgdmFydHlwZSA9ICJjaSIpCnR3LnVzby53ZWlnaHRlZApgYGAKClBhcmEgcG9kZXIgZ3JhZmljYXIsIGVzdG9zIGPDoWxjdWxvcyBzZSBndWFyZGFuIGVuIHVuIGRhdGFmcmFtZSAidHcudXNvLndlaWdodGVkIiwgcXVlIGluY2x1eWUgbG9zIGRhdG9zIGRlIGxhIG1lZGlhIHBvciBjYWRhIGdydXBvIHkgZWwgbMOtbWl0ZSBpbmZlcmlvciB5IHN1cGVyaW9yIGRlbCBpbnRlcnZhbG8gZGUgY29uZmlhbnphLgpEZSBsYSBtaXNtYSBtYW5lcmEgcXVlIGNvbiBsb3MgZGF0b3MgcXVlIG5vIGluY2x1eWVuIGVsIGVmZWN0byBkZSBkaXNlw7FvLCBzZSB1c2EgbGEgbGlicmVyw61hIGBnZ3Bsb3RgIHkgc2UgY3JlYSB1biBncsOhZmljbyBxdWUgc2UgZ3VhcmRhIGVuIHVuIG9iamV0byAiZ3JhZjIiLgpTZSB1c2FuIGVzcGVjaWZpY2FjaW9uZXMgbXV5IHNpbWlsYXJlcyBhIGxvcyBlamVtcGxvcyBhbnRlcmlvcmVzLgoKYGBge3Igd2VpZ2h0ZWRiYXJyYXN9CmdyYWY0IDwtIGdncGxvdCh0dy51c28ud2VpZ2h0ZWQsIGFlcyh4PXNtZWRpYTVyLCB5PXBuNHJyKSkrCiAgZ2VvbV9iYXIod2lkdGg9MC41LCBmaWxsPSJkYXJrY3lhbiIsIGNvbG91cj0iYmxhY2siLCBzdGF0PSJpZGVudGl0eSIpKwogIGdlb21fZXJyb3JiYXIoYWVzKHltaW49Y2lfbCwgeW1heD1jaV91KSwgd2lkdGg9MC4yKSsKICBnZW9tX3RleHQoYWVzKGxhYmVsPXBhc3RlKHJvdW5kKHBuNHJyLCAxKSwgIiUiKSksIHZqdXN0PS00LjIsIHNpemU9NCkrCiAgeGxhYigiVGlwbyBkZSB1c3VhcmlvIGRlIFR3aXR0ZXIiKSArIHlsYWIoIlNhdGlzZmFjY2nDs24gY29uIGxhIGRlbW9jcmFjaWEgKCUpIikrCiAgeWxpbSgwLCA1MCkKZ3JhZjQKYGBgCgpFc3RvcyByZXN1bHRhZG9zIGluY2x1eWVuIGVsIGVmZWN0byBkZSBkaXNlw7FvLCBwZXJvIG5vIHNvbiBleGFjdGFtZW50ZSBpZ3VhbGVzIGEgbG9zIHJlcG9ydGFkb3MgZW4gZWwgZ3LDoWZpY28gMy45IGRlbCByZXBvcnRlIEVsIFB1bHNvIGRlIGxhIERlbW9jcmFjaWEgZGUgbGEgcm9uZGEgMjAxOC8xOSBkZWJpZG8gYSBxdWUgZWwgY8OhbGN1bG8gZGUgbGEgdmFyaWFibGUgcXVlIGRlZmluZSBhbCB0aXBvIGRlIHVzdWFyaW8gZGUgVHdpdHRlciBlcyBtw6FzIGNvbXBsZWpvIGRlIGxvIHF1ZSBzZSBoYWNlIGVuIGVzdGEgc2VjY2nDs24uCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("IC.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
